{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TradeTracer Executor","text":"<p>Execute your TradeTracer trading strategies with your own broker.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>You                          TradeTracer\n \u2502                               \u2502\n \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n \u2502  \u2502     Executor         \u2502     \u2502\n \u2502  \u2502                      \u2502     \u2502\n \u2502  \u2502  1. Report fills  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502\n \u2502  \u2502  2. Receive orders \u25c4\u2500\u2500\u2500\u2500\u2500\u2500 \u2502\n \u2502  \u2502  3. Execute orders \u2500\u2500\u25ba Broker\n \u2502  \u2502  4. Repeat           \u2502     \u2502\n \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n</code></pre> <ol> <li>TradeTracer runs your strategy and decides when to buy/sell</li> <li>Executor receives orders and executes them with your broker</li> <li>Executor reports fills back to TradeTracer</li> <li>Repeat every tick</li> </ol>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>docker run -p 5000:5000 -v tradetracer:/data tradetracer/executor\n</code></pre> <p>Open http://localhost:5000, enter your API key, click Start.</p>"},{"location":"#adapters","title":"Adapters","text":"Adapter Description Sandbox Paper trading for testing, no real money IBKR Interactive Brokers via TWS/Gateway <p>Need a different broker? See Custom Adapters.</p>"},{"location":"custom-adapters/","title":"Custom Adapters","text":"<p>How to connect the executor to your broker.</p>"},{"location":"custom-adapters/#interface","title":"Interface","text":"<p>Inherit from <code>BaseAdapter</code> and implement all abstract methods:</p> <pre><code>from adapters.base import BaseAdapter, Quote\n\nclass MyBrokerAdapter(BaseAdapter):\n    def __init__(self, api_key: str = \"\", **kwargs):\n        self.api_key = api_key\n        self.client = None\n\n    @classmethod\n    def get_config_fields(cls):\n        return [\n            {\"name\": \"api_key\", \"label\": \"API Key\", \"type\": \"password\", \"required\": True},\n        ]\n\n    def connect(self) -&gt; bool:\n        self.client = MyBrokerClient(self.api_key)\n        return self.client.is_connected()\n\n    def disconnect(self) -&gt; None:\n        if self.client:\n            self.client.close()\n\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; dict:\n        result = self.client.buy(symbol, shares, limit=price)\n        if result.filled:\n            return {\n                \"success\": True,\n                \"fill_price\": result.price,\n                \"fill_shares\": result.shares,\n                \"commission\": result.commission,\n            }\n        return {\"success\": False, \"error\": result.error}\n\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; dict:\n        result = self.client.sell(symbol, shares, limit=price)\n        if result.filled:\n            return {\n                \"success\": True,\n                \"fill_price\": result.price,\n                \"fill_shares\": result.shares,\n                \"commission\": result.commission,\n            }\n        return {\"success\": False, \"error\": result.error}\n\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        quote = self.client.get_quote(symbol)\n        if not quote:\n            return None\n        return {\n            \"open\": quote.open,\n            \"high\": quote.high,\n            \"low\": quote.low,\n            \"close\": quote.last,\n            \"volume\": quote.volume,\n            \"bid\": quote.bid,\n            \"ask\": quote.ask,\n        }\n</code></pre>"},{"location":"custom-adapters/#register","title":"Register","text":"<p>Add your adapter to <code>adapters/__init__.py</code>:</p> <pre><code>from .my_broker import MyBrokerAdapter\nADAPTERS[\"my_broker\"] = MyBrokerAdapter\n</code></pre>"},{"location":"custom-adapters/#return-formats","title":"Return Formats","text":""},{"location":"custom-adapters/#execute_buy-execute_sell","title":"execute_buy / execute_sell","text":"<pre><code># Success\n{\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n# Failure\n{\"success\": False, \"error\": \"Insufficient funds\"}\n</code></pre>"},{"location":"custom-adapters/#fetch_quote","title":"fetch_quote","text":"<pre><code># Available\n{\"open\": 185.0, \"high\": 187.5, \"low\": 184.25, \"close\": 186.5, \"volume\": 1234567, \"bid\": 186.45, \"ask\": 186.55}\n\n# Unavailable\nNone\n</code></pre> <p>Return <code>None</code> if quotes aren't available. TradeTracer falls back to its EOD cache.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#docker-recommended","title":"Docker (Recommended)","text":"<pre><code>docker run -p 5000:5000 -v tradetracer:/data tradetracer/executor\n</code></pre> <p>Open http://localhost:5000 to configure.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"Field Description API Key Your TradeTracer API key (from the Live tab) Adapter Broker to use (<code>sandbox</code> or <code>ibkr</code>) Poll Interval Seconds between ticks (default: 60)"},{"location":"getting-started/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/tradetracer/executor.git\ncd executor\npip install -r requirements.txt\npython -m web.app\n</code></pre>"},{"location":"getting-started/#persistence","title":"Persistence","text":"<p>Config and pending transactions are stored in <code>/data</code>:</p> <pre><code># Named volume (recommended)\ndocker run -v tradetracer:/data tradetracer/executor\n\n# Bind mount\ndocker run -v ./my-data:/data tradetracer/executor\n</code></pre>"},{"location":"getting-started/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/ -v\n</code></pre>"},{"location":"reference/adapters/","title":"Adapters","text":"<p>Adapter registry and factory functions.</p>"},{"location":"reference/adapters/#adapters","title":"<code>adapters</code>","text":"<p>Broker adapters for TradeTracer Executor.</p> <p>This module provides the adapter registry and factory functions for creating broker adapter instances.</p> Available Adapters <ul> <li><code>sandbox</code>: Paper trading with SQLite (always available)</li> <li><code>ibkr</code>: Interactive Brokers via TWS/Gateway (requires ib_insync)</li> </ul> Example <pre><code>from adapters import get_adapter, list_adapters\n\n# See available adapters\nprint(list_adapters())  # [\"sandbox\", \"ibkr\"]\n\n# Create an adapter\nadapter = get_adapter(\"sandbox\", {\"initial_cash\": 100000})\nadapter.connect()\n\n# Execute an order\nresult = adapter.execute_order({\n    \"action\": \"buy\",\n    \"symbol\": \"AAPL\",\n    \"volume\": 10,\n    \"price\": 186.50\n})\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter","title":"<code>BaseAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for broker adapters.</p> <p>An adapter is the bridge between the executor and a specific broker. It knows how to connect to the broker, execute buy/sell orders, and optionally fetch real-time quotes. The executor owns the lifecycle \u2014 it calls <code>connect()</code> on start, <code>fetch_quote()</code> and <code>execute_buy()</code>/ <code>execute_sell()</code> during each tick, and <code>disconnect()</code> on stop.</p> <p>Adapters should never raise exceptions for expected failures like insufficient funds or rejected orders. Instead, return a result dict with <code>\"success\": False</code> and an <code>\"error\"</code> message. The executor logs these and continues to the next order.</p> Source code in <code>adapters/base.py</code> <pre><code>class BaseAdapter(ABC):\n    \"\"\"\n    Abstract base class for broker adapters.\n\n    An adapter is the bridge between the executor and a specific broker.\n    It knows how to connect to the broker, execute buy/sell orders, and\n    optionally fetch real-time quotes. The executor owns the lifecycle \u2014\n    it calls `connect()` on start, `fetch_quote()` and `execute_buy()`/\n    `execute_sell()` during each tick, and `disconnect()` on stop.\n\n    Adapters should never raise exceptions for expected failures like\n    insufficient funds or rejected orders. Instead, return a result dict\n    with `\"success\": False` and an `\"error\"` message. The executor logs\n    these and continues to the next order.\n    \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def get_config_fields(cls) -&gt; list[ConfigField]:\n        \"\"\"\n        Return configuration fields for the web UI.\n\n        Called by the web UI when rendering the adapter configuration form.\n        Each field describes one input the user needs to fill in to connect\n        to this broker \u2014 for example, an API key, a hostname, or a port number.\n\n        The web UI dynamically renders form inputs based on these field\n        definitions. When the user saves, the values are stored in\n        `config.json` under `adapter_config` and passed as keyword arguments\n        to the adapter's `__init__()`. The `name` of each field must match\n        an `__init__` parameter name so the value gets passed through.\n\n        Returns:\n            List of field configuration dicts. Each dict has `name`, `label`,\n            `type` (text/password/number/checkbox/select), and optionally\n            `required`, `default`, and `options`.\n\n        Example:\n            ```python\n            @classmethod\n            def get_config_fields(cls):\n                return [\n                    {\n                        \"name\": \"api_key\",\n                        \"label\": \"API Key\",\n                        \"type\": \"password\",\n                        \"required\": True\n                    },\n                    {\n                        \"name\": \"sandbox\",\n                        \"label\": \"Paper Trading\",\n                        \"type\": \"checkbox\",\n                        \"default\": True\n                    },\n                ]\n            ```\n        \"\"\"\n\n    @abstractmethod\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to the broker and verify the session is usable.\n\n        Called exactly once when the user starts the executor. This is where\n        the adapter should establish a network connection, authenticate with\n        credentials, and verify that the session is ready to accept orders.\n\n        If the connection fails \u2014 wrong credentials, broker offline, network\n        error \u2014 return False. The executor will log the failure, stay in the\n        stopped state, and the user can fix their config and try again.\n\n        For adapters that don't need a persistent connection (like the sandbox\n        adapter), this can simply return True.\n\n        Returns:\n            True if the connection was established and the adapter is ready\n            to execute orders. False if something went wrong.\n        \"\"\"\n\n    @abstractmethod\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnect from the broker and clean up resources.\n\n        Called once when the user stops the executor, or when the container\n        shuts down (via SIGTERM/SIGINT). This is where the adapter should\n        close network connections, cancel any pending requests, and release\n        resources.\n\n        This method should never raise exceptions. If the connection is\n        already closed or was never established, it should silently do nothing.\n        The executor calls this unconditionally during shutdown regardless of\n        the adapter's current state.\n        \"\"\"\n\n    @abstractmethod\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a buy order on the broker.\n\n        Called by the executor when TradeTracer issues a buy order during a\n        tick. The executor receives orders from the TradeTracer API response,\n        then calls this method for each buy order. The adapter should submit\n        the order to the broker and return the fill details.\n\n        The `price` parameter is the ask price that TradeTracer used to size\n        the order. Depending on your broker integration, you can use it as a\n        limit price, a sanity check against slippage, or ignore it entirely\n        and use a market order. The fill price you report back is what\n        TradeTracer records as the actual execution price.\n\n        On success, you must return all four fields: `success`, `fill_price`,\n        `fill_shares`, and `commission`. The executor builds a transaction\n        from these and reports it to TradeTracer on the next tick.\n\n        On failure (insufficient funds, symbol not found, broker rejected the\n        order), return `\"success\": False` with an `\"error\"` message. Do not\n        raise exceptions \u2014 the executor logs the error and moves on to the\n        next order.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n                uppercase, as provided by TradeTracer.\n            shares: Number of shares to buy. Always a positive integer.\n                This is the net consolidated volume from TradeTracer \u2014 if\n                a strategy called `buy(50)` then `sell(20)` in the same\n                tick, you receive `shares=30`.\n            price: The ask price TradeTracer used when generating this\n                order. Use as a limit price or for slippage validation.\n\n        Returns:\n            A dict with `success`, `fill_price`, `fill_shares`, and `commission`\n            on success, or `success` and `error` on failure.\n\n        Example:\n            ```python\n            # Success\n            {\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n            # Failure\n            {\"success\": False, \"error\": \"Insufficient funds\"}\n            ```\n        \"\"\"\n\n    @abstractmethod\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a sell order on the broker.\n\n        Called by the executor when TradeTracer issues a sell order during a\n        tick. Behaves identically to `execute_buy()` but for the sell side.\n\n        The `price` parameter is the bid price that TradeTracer used to\n        calculate expected proceeds. As with buys, you can use it as a limit,\n        a sanity check, or ignore it.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n                uppercase, as provided by TradeTracer.\n            shares: Number of shares to sell. Always a positive integer.\n                The executor only sends sell orders for positions the strategy\n                holds, but the adapter should still validate against its own\n                position tracking in case of desync.\n            price: The bid price TradeTracer used when generating this\n                order. Use as a limit price or for slippage validation.\n\n        Returns:\n            Same format as `execute_buy()` \u2014 a dict with `success`, `fill_price`,\n            `fill_shares`, and `commission` on success, or `success` and `error`\n            on failure.\n        \"\"\"\n\n    @abstractmethod\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        \"\"\"\n        Fetch a price quote for a symbol.\n\n        Called by the executor at the start of every tick, once per tracked\n        symbol. The executor sends the returned quotes to TradeTracer, which\n        uses them for intraday strategy evaluation and order pricing.\n\n        The `eod_last_price` is the most recent end-of-day close price from\n        TradeTracer's data. Adapters can use it however they need \u2014 for\n        example, the sandbox adapter uses it to simulate intraday price\n        movement via random walk. Broker adapters like IBKR can ignore it\n        and fetch real-time data from the broker instead.\n\n        The EOD price also serves as a sanity check \u2014 users can compare\n        their broker's price against TradeTracer's data to verify accuracy.\n        TradeTracer's data is not always correct, and this transparency\n        helps users catch discrepancies.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`). Always uppercase.\n            eod_last_price: Last known EOD close price from TradeTracer,\n                or None if not yet available (first tick).\n\n        Returns:\n            A Quote dict with price fields, or None if unavailable.\n\n        Example:\n            ```python\n            # Broker adapter \u2014 fetch real data, ignore EOD\n            def fetch_quote(self, symbol, eod_last_price):\n                ticker = self.client.get_ticker(symbol)\n                return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n            # Sandbox adapter \u2014 simulate from EOD\n            def fetch_quote(self, symbol, eod_last_price):\n                if not eod_last_price:\n                    return None\n                price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n                return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n            ```\n        \"\"\"\n\n    def execute_order(self, order: Order) -&gt; FillResult:\n        \"\"\"\n        Dispatch an order from TradeTracer to the appropriate handler.\n\n        This is the method the executor loop actually calls. It reads the\n        `action` field from the order dict and routes to `execute_buy()` or\n        `execute_sell()`. You do not need to override this method \u2014 it\n        exists as a convenience so the executor doesn't need to branch on\n        order type itself.\n\n        The order dict comes directly from the TradeTracer API response.\n        Each order represents a consolidated net trade for one symbol from\n        one worker during one tick. TradeTracer handles consolidation \u2014 if\n        a strategy called `buy(50)` then `sell(20)`, you receive a single\n        order with `action: \"buy\"` and `volume: 30`.\n\n        Args:\n            order: Order dict from the TradeTracer API response with keys:\n\n                - `action` (str): `\"buy\"` or `\"sell\"`.\n                - `symbol` (str): Stock ticker symbol, uppercase.\n                - `volume` (int): Number of shares (always positive).\n                - `price` (float): Ask price for buys, bid price for sells.\n                - `order_id` (str): UUID that links this order to the\n                  transaction reported back on the next tick.\n\n        Returns:\n            The result dict from `execute_buy()` or `execute_sell()`.\n\n        Example:\n            ```python\n            order = {\n                \"action\": \"buy\",\n                \"symbol\": \"AAPL\",\n                \"volume\": 100,\n                \"price\": 186.50,\n                \"order_id\": \"abc-123\"\n            }\n            result = adapter.execute_order(order)\n            ```\n        \"\"\"\n        if order[\"action\"] == \"buy\":\n            return self.execute_buy(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n        else:\n            return self.execute_sell(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.get_config_fields","title":"<code>get_config_fields()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Return configuration fields for the web UI.</p> <p>Called by the web UI when rendering the adapter configuration form. Each field describes one input the user needs to fill in to connect to this broker \u2014 for example, an API key, a hostname, or a port number.</p> <p>The web UI dynamically renders form inputs based on these field definitions. When the user saves, the values are stored in <code>config.json</code> under <code>adapter_config</code> and passed as keyword arguments to the adapter's <code>__init__()</code>. The <code>name</code> of each field must match an <code>__init__</code> parameter name so the value gets passed through.</p> <p>Returns:</p> Type Description <code>list[ConfigField]</code> <p>List of field configuration dicts. Each dict has <code>name</code>, <code>label</code>, <code>type</code> (text/password/number/checkbox/select), and optionally <code>required</code>, <code>default</code>, and <code>options</code>.</p> Example <pre><code>@classmethod\ndef get_config_fields(cls):\n    return [\n        {\n            \"name\": \"api_key\",\n            \"label\": \"API Key\",\n            \"type\": \"password\",\n            \"required\": True\n        },\n        {\n            \"name\": \"sandbox\",\n            \"label\": \"Paper Trading\",\n            \"type\": \"checkbox\",\n            \"default\": True\n        },\n    ]\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_config_fields(cls) -&gt; list[ConfigField]:\n    \"\"\"\n    Return configuration fields for the web UI.\n\n    Called by the web UI when rendering the adapter configuration form.\n    Each field describes one input the user needs to fill in to connect\n    to this broker \u2014 for example, an API key, a hostname, or a port number.\n\n    The web UI dynamically renders form inputs based on these field\n    definitions. When the user saves, the values are stored in\n    `config.json` under `adapter_config` and passed as keyword arguments\n    to the adapter's `__init__()`. The `name` of each field must match\n    an `__init__` parameter name so the value gets passed through.\n\n    Returns:\n        List of field configuration dicts. Each dict has `name`, `label`,\n        `type` (text/password/number/checkbox/select), and optionally\n        `required`, `default`, and `options`.\n\n    Example:\n        ```python\n        @classmethod\n        def get_config_fields(cls):\n            return [\n                {\n                    \"name\": \"api_key\",\n                    \"label\": \"API Key\",\n                    \"type\": \"password\",\n                    \"required\": True\n                },\n                {\n                    \"name\": \"sandbox\",\n                    \"label\": \"Paper Trading\",\n                    \"type\": \"checkbox\",\n                    \"default\": True\n                },\n            ]\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Connect to the broker and verify the session is usable.</p> <p>Called exactly once when the user starts the executor. This is where the adapter should establish a network connection, authenticate with credentials, and verify that the session is ready to accept orders.</p> <p>If the connection fails \u2014 wrong credentials, broker offline, network error \u2014 return False. The executor will log the failure, stay in the stopped state, and the user can fix their config and try again.</p> <p>For adapters that don't need a persistent connection (like the sandbox adapter), this can simply return True.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the connection was established and the adapter is ready to execute orders. False if something went wrong.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef connect(self) -&gt; bool:\n    \"\"\"\n    Connect to the broker and verify the session is usable.\n\n    Called exactly once when the user starts the executor. This is where\n    the adapter should establish a network connection, authenticate with\n    credentials, and verify that the session is ready to accept orders.\n\n    If the connection fails \u2014 wrong credentials, broker offline, network\n    error \u2014 return False. The executor will log the failure, stay in the\n    stopped state, and the user can fix their config and try again.\n\n    For adapters that don't need a persistent connection (like the sandbox\n    adapter), this can simply return True.\n\n    Returns:\n        True if the connection was established and the adapter is ready\n        to execute orders. False if something went wrong.\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Disconnect from the broker and clean up resources.</p> <p>Called once when the user stops the executor, or when the container shuts down (via SIGTERM/SIGINT). This is where the adapter should close network connections, cancel any pending requests, and release resources.</p> <p>This method should never raise exceptions. If the connection is already closed or was never established, it should silently do nothing. The executor calls this unconditionally during shutdown regardless of the adapter's current state.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the broker and clean up resources.\n\n    Called once when the user stops the executor, or when the container\n    shuts down (via SIGTERM/SIGINT). This is where the adapter should\n    close network connections, cancel any pending requests, and release\n    resources.\n\n    This method should never raise exceptions. If the connection is\n    already closed or was never established, it should silently do nothing.\n    The executor calls this unconditionally during shutdown regardless of\n    the adapter's current state.\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.execute_buy","title":"<code>execute_buy(symbol, shares, price)</code>  <code>abstractmethod</code>","text":"<p>Execute a buy order on the broker.</p> <p>Called by the executor when TradeTracer issues a buy order during a tick. The executor receives orders from the TradeTracer API response, then calls this method for each buy order. The adapter should submit the order to the broker and return the fill details.</p> <p>The <code>price</code> parameter is the ask price that TradeTracer used to size the order. Depending on your broker integration, you can use it as a limit price, a sanity check against slippage, or ignore it entirely and use a market order. The fill price you report back is what TradeTracer records as the actual execution price.</p> <p>On success, you must return all four fields: <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code>. The executor builds a transaction from these and reports it to TradeTracer on the next tick.</p> <p>On failure (insufficient funds, symbol not found, broker rejected the order), return <code>\"success\": False</code> with an <code>\"error\"</code> message. Do not raise exceptions \u2014 the executor logs the error and moves on to the next order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>, <code>\"TSLA\"</code>). Always uppercase, as provided by TradeTracer.</p> required <code>shares</code> <code>int</code> <p>Number of shares to buy. Always a positive integer. This is the net consolidated volume from TradeTracer \u2014 if a strategy called <code>buy(50)</code> then <code>sell(20)</code> in the same tick, you receive <code>shares=30</code>.</p> required <code>price</code> <code>float</code> <p>The ask price TradeTracer used when generating this order. Use as a limit price or for slippage validation.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>A dict with <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> on success, or <code>success</code> and <code>error</code> on failure.</p> Example <pre><code># Success\n{\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n# Failure\n{\"success\": False, \"error\": \"Insufficient funds\"}\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a buy order on the broker.\n\n    Called by the executor when TradeTracer issues a buy order during a\n    tick. The executor receives orders from the TradeTracer API response,\n    then calls this method for each buy order. The adapter should submit\n    the order to the broker and return the fill details.\n\n    The `price` parameter is the ask price that TradeTracer used to size\n    the order. Depending on your broker integration, you can use it as a\n    limit price, a sanity check against slippage, or ignore it entirely\n    and use a market order. The fill price you report back is what\n    TradeTracer records as the actual execution price.\n\n    On success, you must return all four fields: `success`, `fill_price`,\n    `fill_shares`, and `commission`. The executor builds a transaction\n    from these and reports it to TradeTracer on the next tick.\n\n    On failure (insufficient funds, symbol not found, broker rejected the\n    order), return `\"success\": False` with an `\"error\"` message. Do not\n    raise exceptions \u2014 the executor logs the error and moves on to the\n    next order.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n            uppercase, as provided by TradeTracer.\n        shares: Number of shares to buy. Always a positive integer.\n            This is the net consolidated volume from TradeTracer \u2014 if\n            a strategy called `buy(50)` then `sell(20)` in the same\n            tick, you receive `shares=30`.\n        price: The ask price TradeTracer used when generating this\n            order. Use as a limit price or for slippage validation.\n\n    Returns:\n        A dict with `success`, `fill_price`, `fill_shares`, and `commission`\n        on success, or `success` and `error` on failure.\n\n    Example:\n        ```python\n        # Success\n        {\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n        # Failure\n        {\"success\": False, \"error\": \"Insufficient funds\"}\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.execute_sell","title":"<code>execute_sell(symbol, shares, price)</code>  <code>abstractmethod</code>","text":"<p>Execute a sell order on the broker.</p> <p>Called by the executor when TradeTracer issues a sell order during a tick. Behaves identically to <code>execute_buy()</code> but for the sell side.</p> <p>The <code>price</code> parameter is the bid price that TradeTracer used to calculate expected proceeds. As with buys, you can use it as a limit, a sanity check, or ignore it.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>, <code>\"TSLA\"</code>). Always uppercase, as provided by TradeTracer.</p> required <code>shares</code> <code>int</code> <p>Number of shares to sell. Always a positive integer. The executor only sends sell orders for positions the strategy holds, but the adapter should still validate against its own position tracking in case of desync.</p> required <code>price</code> <code>float</code> <p>The bid price TradeTracer used when generating this order. Use as a limit price or for slippage validation.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Same format as <code>execute_buy()</code> \u2014 a dict with <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> on success, or <code>success</code> and <code>error</code> on failure.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a sell order on the broker.\n\n    Called by the executor when TradeTracer issues a sell order during a\n    tick. Behaves identically to `execute_buy()` but for the sell side.\n\n    The `price` parameter is the bid price that TradeTracer used to\n    calculate expected proceeds. As with buys, you can use it as a limit,\n    a sanity check, or ignore it.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n            uppercase, as provided by TradeTracer.\n        shares: Number of shares to sell. Always a positive integer.\n            The executor only sends sell orders for positions the strategy\n            holds, but the adapter should still validate against its own\n            position tracking in case of desync.\n        price: The bid price TradeTracer used when generating this\n            order. Use as a limit price or for slippage validation.\n\n    Returns:\n        Same format as `execute_buy()` \u2014 a dict with `success`, `fill_price`,\n        `fill_shares`, and `commission` on success, or `success` and `error`\n        on failure.\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.fetch_quote","title":"<code>fetch_quote(symbol, eod_last_price)</code>  <code>abstractmethod</code>","text":"<p>Fetch a price quote for a symbol.</p> <p>Called by the executor at the start of every tick, once per tracked symbol. The executor sends the returned quotes to TradeTracer, which uses them for intraday strategy evaluation and order pricing.</p> <p>The <code>eod_last_price</code> is the most recent end-of-day close price from TradeTracer's data. Adapters can use it however they need \u2014 for example, the sandbox adapter uses it to simulate intraday price movement via random walk. Broker adapters like IBKR can ignore it and fetch real-time data from the broker instead.</p> <p>The EOD price also serves as a sanity check \u2014 users can compare their broker's price against TradeTracer's data to verify accuracy. TradeTracer's data is not always correct, and this transparency helps users catch discrepancies.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>). Always uppercase.</p> required <code>eod_last_price</code> <code>float | None</code> <p>Last known EOD close price from TradeTracer, or None if not yet available (first tick).</p> required <p>Returns:</p> Type Description <code>Quote | None</code> <p>A Quote dict with price fields, or None if unavailable.</p> Example <pre><code># Broker adapter \u2014 fetch real data, ignore EOD\ndef fetch_quote(self, symbol, eod_last_price):\n    ticker = self.client.get_ticker(symbol)\n    return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n# Sandbox adapter \u2014 simulate from EOD\ndef fetch_quote(self, symbol, eod_last_price):\n    if not eod_last_price:\n        return None\n    price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n    return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n    \"\"\"\n    Fetch a price quote for a symbol.\n\n    Called by the executor at the start of every tick, once per tracked\n    symbol. The executor sends the returned quotes to TradeTracer, which\n    uses them for intraday strategy evaluation and order pricing.\n\n    The `eod_last_price` is the most recent end-of-day close price from\n    TradeTracer's data. Adapters can use it however they need \u2014 for\n    example, the sandbox adapter uses it to simulate intraday price\n    movement via random walk. Broker adapters like IBKR can ignore it\n    and fetch real-time data from the broker instead.\n\n    The EOD price also serves as a sanity check \u2014 users can compare\n    their broker's price against TradeTracer's data to verify accuracy.\n    TradeTracer's data is not always correct, and this transparency\n    helps users catch discrepancies.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`). Always uppercase.\n        eod_last_price: Last known EOD close price from TradeTracer,\n            or None if not yet available (first tick).\n\n    Returns:\n        A Quote dict with price fields, or None if unavailable.\n\n    Example:\n        ```python\n        # Broker adapter \u2014 fetch real data, ignore EOD\n        def fetch_quote(self, symbol, eod_last_price):\n            ticker = self.client.get_ticker(symbol)\n            return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n        # Sandbox adapter \u2014 simulate from EOD\n        def fetch_quote(self, symbol, eod_last_price):\n            if not eod_last_price:\n                return None\n            price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n            return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/adapters/#adapters.BaseAdapter.execute_order","title":"<code>execute_order(order)</code>","text":"<p>Dispatch an order from TradeTracer to the appropriate handler.</p> <p>This is the method the executor loop actually calls. It reads the <code>action</code> field from the order dict and routes to <code>execute_buy()</code> or <code>execute_sell()</code>. You do not need to override this method \u2014 it exists as a convenience so the executor doesn't need to branch on order type itself.</p> <p>The order dict comes directly from the TradeTracer API response. Each order represents a consolidated net trade for one symbol from one worker during one tick. TradeTracer handles consolidation \u2014 if a strategy called <code>buy(50)</code> then <code>sell(20)</code>, you receive a single order with <code>action: \"buy\"</code> and <code>volume: 30</code>.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>Order dict from the TradeTracer API response with keys:</p> <ul> <li><code>action</code> (str): <code>\"buy\"</code> or <code>\"sell\"</code>.</li> <li><code>symbol</code> (str): Stock ticker symbol, uppercase.</li> <li><code>volume</code> (int): Number of shares (always positive).</li> <li><code>price</code> (float): Ask price for buys, bid price for sells.</li> <li><code>order_id</code> (str): UUID that links this order to the   transaction reported back on the next tick.</li> </ul> required <p>Returns:</p> Type Description <code>FillResult</code> <p>The result dict from <code>execute_buy()</code> or <code>execute_sell()</code>.</p> Example <pre><code>order = {\n    \"action\": \"buy\",\n    \"symbol\": \"AAPL\",\n    \"volume\": 100,\n    \"price\": 186.50,\n    \"order_id\": \"abc-123\"\n}\nresult = adapter.execute_order(order)\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>def execute_order(self, order: Order) -&gt; FillResult:\n    \"\"\"\n    Dispatch an order from TradeTracer to the appropriate handler.\n\n    This is the method the executor loop actually calls. It reads the\n    `action` field from the order dict and routes to `execute_buy()` or\n    `execute_sell()`. You do not need to override this method \u2014 it\n    exists as a convenience so the executor doesn't need to branch on\n    order type itself.\n\n    The order dict comes directly from the TradeTracer API response.\n    Each order represents a consolidated net trade for one symbol from\n    one worker during one tick. TradeTracer handles consolidation \u2014 if\n    a strategy called `buy(50)` then `sell(20)`, you receive a single\n    order with `action: \"buy\"` and `volume: 30`.\n\n    Args:\n        order: Order dict from the TradeTracer API response with keys:\n\n            - `action` (str): `\"buy\"` or `\"sell\"`.\n            - `symbol` (str): Stock ticker symbol, uppercase.\n            - `volume` (int): Number of shares (always positive).\n            - `price` (float): Ask price for buys, bid price for sells.\n            - `order_id` (str): UUID that links this order to the\n              transaction reported back on the next tick.\n\n    Returns:\n        The result dict from `execute_buy()` or `execute_sell()`.\n\n    Example:\n        ```python\n        order = {\n            \"action\": \"buy\",\n            \"symbol\": \"AAPL\",\n            \"volume\": 100,\n            \"price\": 186.50,\n            \"order_id\": \"abc-123\"\n        }\n        result = adapter.execute_order(order)\n        ```\n    \"\"\"\n    if order[\"action\"] == \"buy\":\n        return self.execute_buy(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n    else:\n        return self.execute_sell(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n</code></pre>"},{"location":"reference/adapters/#adapters.ConfigField","title":"<code>ConfigField</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration field for the web UI form.</p> <p>Displayed as a form input in the executor's web interface. The <code>name</code> must match an <code>__init__</code> parameter on the adapter.</p> Source code in <code>adapters/base.py</code> <pre><code>class ConfigField(TypedDict, total=False):\n    \"\"\"\n    Configuration field for the web UI form.\n\n    Displayed as a form input in the executor's web interface.\n    The `name` must match an `__init__` parameter on the adapter.\n    \"\"\"\n\n    name: str\n    label: str\n    type: Literal[\"text\", \"password\", \"number\", \"checkbox\", \"select\"]\n    required: bool\n    default: Any\n    options: list[dict[str, str]]\n</code></pre>"},{"location":"reference/adapters/#adapters.FillResult","title":"<code>FillResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result of executing a buy or sell order.</p> <p>On success, <code>success</code> is True and <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> are set. On failure, <code>success</code> is False and <code>error</code> describes what went wrong.</p> Source code in <code>adapters/base.py</code> <pre><code>class FillResult(TypedDict, total=False):\n    \"\"\"\n    Result of executing a buy or sell order.\n\n    On success, `success` is True and `fill_price`, `fill_shares`,\n    and `commission` are set. On failure, `success` is False and\n    `error` describes what went wrong.\n    \"\"\"\n\n    success: bool\n    fill_price: float\n    fill_shares: int\n    commission: float\n    error: str\n</code></pre>"},{"location":"reference/adapters/#adapters.Order","title":"<code>Order</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Order from the TradeTracer API.</p> <p>Passed to <code>execute_order()</code>, which dispatches to <code>execute_buy()</code> or <code>execute_sell()</code>.</p> Source code in <code>adapters/base.py</code> <pre><code>class Order(TypedDict):\n    \"\"\"\n    Order from the TradeTracer API.\n\n    Passed to `execute_order()`, which dispatches to\n    `execute_buy()` or `execute_sell()`.\n    \"\"\"\n\n    order_id: str\n    action: Literal[\"buy\", \"sell\"]\n    symbol: str\n    volume: int\n    price: float\n</code></pre>"},{"location":"reference/adapters/#adapters.Quote","title":"<code>Quote</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Price quote for a symbol.</p> <p>Returned by <code>fetch_quote()</code>. The executor maps this into the TradeTracer API format (<code>ohlcv</code> with <code>bid</code>/<code>ask</code>) before sending. All fields are optional \u2014 return whatever the broker provides.</p> Source code in <code>adapters/base.py</code> <pre><code>class Quote(TypedDict, total=False):\n    \"\"\"\n    Price quote for a symbol.\n\n    Returned by `fetch_quote()`. The executor maps this into the\n    TradeTracer API format (`ohlcv` with `bid`/`ask`) before sending.\n    All fields are optional \u2014 return whatever the broker provides.\n    \"\"\"\n\n    open: float | None\n    high: float | None\n    low: float | None\n    close: float | None\n    volume: int | None\n    bid: float | None\n    ask: float | None\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter","title":"<code>SandboxAdapter</code>","text":"<p>               Bases: <code>BaseAdapter</code></p> <p>Paper trading adapter.</p> <p>Every order fills immediately at the requested price. Intraday prices are simulated as a random walk from the EOD close.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>class SandboxAdapter(BaseAdapter):\n    \"\"\"\n    Paper trading adapter.\n\n    Every order fills immediately at the requested price.\n    Intraday prices are simulated as a random walk from the EOD close.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self._last_prices: dict[str, float] = {}\n        self._session: dict[str, dict] = {}  # {symbol: {open, high, low}}\n\n    @classmethod\n    def get_config_fields(cls) -&gt; list[ConfigField]:\n        \"\"\"\n        Return configuration fields for web UI.\n\n        Returns:\n            Empty list \u2014 sandbox needs no configuration.\n        \"\"\"\n        return []\n\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to sandbox.\n\n        Returns:\n            Always True.\n        \"\"\"\n        return True\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from sandbox.\"\"\"\n        self._last_prices.clear()\n        self._session.clear()\n\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a buy order.\n\n        Fills immediately at the given price with zero commission.\n\n        Args:\n            symbol: Stock symbol.\n            shares: Number of shares to buy.\n            price: Price per share.\n\n        Returns:\n            Fill result with the requested price and shares.\n        \"\"\"\n        return {\n            \"success\": True,\n            \"fill_price\": price,\n            \"fill_shares\": shares,\n            \"commission\": 0.0,\n        }\n\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a sell order.\n\n        Fills immediately at the given price with zero commission.\n\n        Args:\n            symbol: Stock symbol.\n            shares: Number of shares to sell.\n            price: Price per share.\n\n        Returns:\n            Fill result with the requested price and shares.\n        \"\"\"\n        return {\n            \"success\": True,\n            \"fill_price\": price,\n            \"fill_shares\": shares,\n            \"commission\": 0.0,\n        }\n\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        \"\"\"\n        Simulate an intraday quote via random walk.\n\n        On the first call for a symbol, starts from the EOD close price.\n        On subsequent calls, walks from the previous simulated price.\n        Uses a random walk to simulate realistic intraday movement.\n\n        Args:\n            symbol: Stock symbol.\n            eod_last_price: Last EOD close from TradeTracer.\n\n        Returns:\n            Simulated quote, or None if no EOD price available.\n        \"\"\"\n        if not eod_last_price:\n            return None\n\n        base = self._last_prices.get(symbol, eod_last_price)\n        step = random.uniform(-0.005, 0.005)\n        price = round(base * (1 + step), 2)\n        self._last_prices[symbol] = price\n\n        # Track intraday session (open/high/low)\n        if symbol not in self._session:\n            self._session[symbol] = {\"open\": price, \"high\": price, \"low\": price}\n        sess = self._session[symbol]\n        sess[\"high\"] = max(sess[\"high\"], price)\n        sess[\"low\"] = min(sess[\"low\"], price)\n\n        # Spread: 0.01-0.05% of price, varies per tick\n        spread_pct = random.uniform(0.0001, 0.0005)\n        half_spread = round(price * spread_pct, 2) or 0.01\n\n        # Bid/ask: last trade (close) is between bid and ask\n        bid = round(price - half_spread, 2)\n        ask = round(price + half_spread, 2)\n\n        return {\n            \"open\": sess[\"open\"],\n            \"high\": sess[\"high\"],\n            \"low\": sess[\"low\"],\n            \"close\": price,\n            \"volume\": random.randint(100, 5000),\n            \"bid\": bid,\n            \"ask\": ask,\n        }\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.get_config_fields","title":"<code>get_config_fields()</code>  <code>classmethod</code>","text":"<p>Return configuration fields for web UI.</p> <p>Returns:</p> Type Description <code>list[ConfigField]</code> <p>Empty list \u2014 sandbox needs no configuration.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>@classmethod\ndef get_config_fields(cls) -&gt; list[ConfigField]:\n    \"\"\"\n    Return configuration fields for web UI.\n\n    Returns:\n        Empty list \u2014 sandbox needs no configuration.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.connect","title":"<code>connect()</code>","text":"<p>Connect to sandbox.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Always True.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def connect(self) -&gt; bool:\n    \"\"\"\n    Connect to sandbox.\n\n    Returns:\n        Always True.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from sandbox.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from sandbox.\"\"\"\n    self._last_prices.clear()\n    self._session.clear()\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.execute_buy","title":"<code>execute_buy(symbol, shares, price)</code>","text":"<p>Execute a buy order.</p> <p>Fills immediately at the given price with zero commission.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>shares</code> <code>int</code> <p>Number of shares to buy.</p> required <code>price</code> <code>float</code> <p>Price per share.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill result with the requested price and shares.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a buy order.\n\n    Fills immediately at the given price with zero commission.\n\n    Args:\n        symbol: Stock symbol.\n        shares: Number of shares to buy.\n        price: Price per share.\n\n    Returns:\n        Fill result with the requested price and shares.\n    \"\"\"\n    return {\n        \"success\": True,\n        \"fill_price\": price,\n        \"fill_shares\": shares,\n        \"commission\": 0.0,\n    }\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.execute_sell","title":"<code>execute_sell(symbol, shares, price)</code>","text":"<p>Execute a sell order.</p> <p>Fills immediately at the given price with zero commission.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>shares</code> <code>int</code> <p>Number of shares to sell.</p> required <code>price</code> <code>float</code> <p>Price per share.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill result with the requested price and shares.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a sell order.\n\n    Fills immediately at the given price with zero commission.\n\n    Args:\n        symbol: Stock symbol.\n        shares: Number of shares to sell.\n        price: Price per share.\n\n    Returns:\n        Fill result with the requested price and shares.\n    \"\"\"\n    return {\n        \"success\": True,\n        \"fill_price\": price,\n        \"fill_shares\": shares,\n        \"commission\": 0.0,\n    }\n</code></pre>"},{"location":"reference/adapters/#adapters.SandboxAdapter.fetch_quote","title":"<code>fetch_quote(symbol, eod_last_price)</code>","text":"<p>Simulate an intraday quote via random walk.</p> <p>On the first call for a symbol, starts from the EOD close price. On subsequent calls, walks from the previous simulated price. Uses a random walk to simulate realistic intraday movement.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>eod_last_price</code> <code>float | None</code> <p>Last EOD close from TradeTracer.</p> required <p>Returns:</p> Type Description <code>Quote | None</code> <p>Simulated quote, or None if no EOD price available.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n    \"\"\"\n    Simulate an intraday quote via random walk.\n\n    On the first call for a symbol, starts from the EOD close price.\n    On subsequent calls, walks from the previous simulated price.\n    Uses a random walk to simulate realistic intraday movement.\n\n    Args:\n        symbol: Stock symbol.\n        eod_last_price: Last EOD close from TradeTracer.\n\n    Returns:\n        Simulated quote, or None if no EOD price available.\n    \"\"\"\n    if not eod_last_price:\n        return None\n\n    base = self._last_prices.get(symbol, eod_last_price)\n    step = random.uniform(-0.005, 0.005)\n    price = round(base * (1 + step), 2)\n    self._last_prices[symbol] = price\n\n    # Track intraday session (open/high/low)\n    if symbol not in self._session:\n        self._session[symbol] = {\"open\": price, \"high\": price, \"low\": price}\n    sess = self._session[symbol]\n    sess[\"high\"] = max(sess[\"high\"], price)\n    sess[\"low\"] = min(sess[\"low\"], price)\n\n    # Spread: 0.01-0.05% of price, varies per tick\n    spread_pct = random.uniform(0.0001, 0.0005)\n    half_spread = round(price * spread_pct, 2) or 0.01\n\n    # Bid/ask: last trade (close) is between bid and ask\n    bid = round(price - half_spread, 2)\n    ask = round(price + half_spread, 2)\n\n    return {\n        \"open\": sess[\"open\"],\n        \"high\": sess[\"high\"],\n        \"low\": sess[\"low\"],\n        \"close\": price,\n        \"volume\": random.randint(100, 5000),\n        \"bid\": bid,\n        \"ask\": ask,\n    }\n</code></pre>"},{"location":"reference/adapters/#adapters.get_adapter","title":"<code>get_adapter(adapter_type, config)</code>","text":"<p>Create an adapter instance by type.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_type</code> <code>str</code> <p>Adapter identifier (e.g., \"sandbox\", \"ibkr\").</p> required <code>config</code> <code>dict[str, Any]</code> <p>Adapter-specific configuration dict.</p> required <p>Returns:</p> Type Description <code>BaseAdapter</code> <p>Configured adapter instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If adapter_type is unknown.</p> Example <pre><code>adapter = get_adapter(\"sandbox\", {\"initial_cash\": 50000})\n</code></pre> Source code in <code>adapters/__init__.py</code> <pre><code>def get_adapter(adapter_type: str, config: dict[str, Any]) -&gt; BaseAdapter:\n    \"\"\"\n    Create an adapter instance by type.\n\n    Args:\n        adapter_type: Adapter identifier (e.g., \"sandbox\", \"ibkr\").\n        config: Adapter-specific configuration dict.\n\n    Returns:\n        Configured adapter instance.\n\n    Raises:\n        ValueError: If adapter_type is unknown.\n\n    Example:\n        ```python\n        adapter = get_adapter(\"sandbox\", {\"initial_cash\": 50000})\n        ```\n    \"\"\"\n    adapter_class = ADAPTERS.get(adapter_type)\n    if not adapter_class:\n        available = \", \".join(ADAPTERS.keys())\n        raise ValueError(f\"Unknown adapter: {adapter_type}. Available: {available}\")\n    return adapter_class(**config)\n</code></pre>"},{"location":"reference/adapters/#adapters.get_adapter_fields","title":"<code>get_adapter_fields(adapter_type)</code>","text":"<p>Get configuration fields for an adapter's web UI.</p> <p>Parameters:</p> Name Type Description Default <code>adapter_type</code> <code>str</code> <p>Adapter identifier.</p> required <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of field configuration dicts, or empty list if unknown.</p> Example <pre><code>fields = get_adapter_fields(\"sandbox\")\n# [{\"name\": \"initial_cash\", \"type\": \"number\", ...}]\n</code></pre> Source code in <code>adapters/__init__.py</code> <pre><code>def get_adapter_fields(adapter_type: str) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get configuration fields for an adapter's web UI.\n\n    Args:\n        adapter_type: Adapter identifier.\n\n    Returns:\n        List of field configuration dicts, or empty list if unknown.\n\n    Example:\n        ```python\n        fields = get_adapter_fields(\"sandbox\")\n        # [{\"name\": \"initial_cash\", \"type\": \"number\", ...}]\n        ```\n    \"\"\"\n    adapter_class = ADAPTERS.get(adapter_type)\n    if not adapter_class:\n        return []\n    return adapter_class.get_config_fields()\n</code></pre>"},{"location":"reference/adapters/#adapters.list_adapters","title":"<code>list_adapters()</code>","text":"<p>List available adapter types.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of adapter identifiers.</p> Example <pre><code>adapters = list_adapters()\n# [\"sandbox\", \"ibkr\"]\n</code></pre> Source code in <code>adapters/__init__.py</code> <pre><code>def list_adapters() -&gt; list[str]:\n    \"\"\"\n    List available adapter types.\n\n    Returns:\n        List of adapter identifiers.\n\n    Example:\n        ```python\n        adapters = list_adapters()\n        # [\"sandbox\", \"ibkr\"]\n        ```\n    \"\"\"\n    return list(ADAPTERS.keys())\n</code></pre>"},{"location":"reference/base-adapter/","title":"Base Adapter","text":"<p>Abstract interface that all broker adapters implement.</p>"},{"location":"reference/base-adapter/#adapters.base","title":"<code>base</code>","text":"<p>Base adapter interface for broker integrations.</p> <p>All broker adapters must inherit from BaseAdapter and implement the required abstract methods. The executor loop calls these methods at specific points during its tick cycle \u2014 adapters never drive the flow themselves, they only respond when the executor invokes them.</p> <p>The typical lifecycle is:</p> <ol> <li>User clicks Start in the web UI.</li> <li>The executor calls <code>connect()</code> once to establish a broker session.</li> <li>On every tick, the executor calls <code>fetch_quote()</code> for each tracked    symbol, then sends prices and pending transactions to TradeTracer.</li> <li>TradeTracer responds with orders. The executor calls <code>execute_order()</code>,    which dispatches to <code>execute_buy()</code> or <code>execute_sell()</code>.</li> <li>When the user clicks Stop, the executor calls <code>disconnect()</code>.</li> </ol> Example <pre><code>from adapters.base import BaseAdapter\n\nclass MyBrokerAdapter(BaseAdapter):\n    @classmethod\n    def get_config_fields(cls):\n        return [{\"name\": \"api_key\", \"type\": \"password\", \"required\": True}]\n\n    def connect(self) -&gt; bool:\n        self.client = MyBrokerClient(self.api_key)\n        return self.client.is_connected()\n\n    def disconnect(self) -&gt; None:\n        self.client.close()\n\n    def execute_buy(self, symbol, shares, price):\n        result = self.client.buy(symbol, shares)\n        return {\"success\": True, \"fill_price\": result.price, ...}\n\n    def execute_sell(self, symbol, shares, price):\n        result = self.client.sell(symbol, shares)\n        return {\"success\": True, \"fill_price\": result.price, ...}\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.ConfigField","title":"<code>ConfigField</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Configuration field for the web UI form.</p> <p>Displayed as a form input in the executor's web interface. The <code>name</code> must match an <code>__init__</code> parameter on the adapter.</p> Source code in <code>adapters/base.py</code> <pre><code>class ConfigField(TypedDict, total=False):\n    \"\"\"\n    Configuration field for the web UI form.\n\n    Displayed as a form input in the executor's web interface.\n    The `name` must match an `__init__` parameter on the adapter.\n    \"\"\"\n\n    name: str\n    label: str\n    type: Literal[\"text\", \"password\", \"number\", \"checkbox\", \"select\"]\n    required: bool\n    default: Any\n    options: list[dict[str, str]]\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.Quote","title":"<code>Quote</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Price quote for a symbol.</p> <p>Returned by <code>fetch_quote()</code>. The executor maps this into the TradeTracer API format (<code>ohlcv</code> with <code>bid</code>/<code>ask</code>) before sending. All fields are optional \u2014 return whatever the broker provides.</p> Source code in <code>adapters/base.py</code> <pre><code>class Quote(TypedDict, total=False):\n    \"\"\"\n    Price quote for a symbol.\n\n    Returned by `fetch_quote()`. The executor maps this into the\n    TradeTracer API format (`ohlcv` with `bid`/`ask`) before sending.\n    All fields are optional \u2014 return whatever the broker provides.\n    \"\"\"\n\n    open: float | None\n    high: float | None\n    low: float | None\n    close: float | None\n    volume: int | None\n    bid: float | None\n    ask: float | None\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.FillResult","title":"<code>FillResult</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Result of executing a buy or sell order.</p> <p>On success, <code>success</code> is True and <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> are set. On failure, <code>success</code> is False and <code>error</code> describes what went wrong.</p> Source code in <code>adapters/base.py</code> <pre><code>class FillResult(TypedDict, total=False):\n    \"\"\"\n    Result of executing a buy or sell order.\n\n    On success, `success` is True and `fill_price`, `fill_shares`,\n    and `commission` are set. On failure, `success` is False and\n    `error` describes what went wrong.\n    \"\"\"\n\n    success: bool\n    fill_price: float\n    fill_shares: int\n    commission: float\n    error: str\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.Order","title":"<code>Order</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Order from the TradeTracer API.</p> <p>Passed to <code>execute_order()</code>, which dispatches to <code>execute_buy()</code> or <code>execute_sell()</code>.</p> Source code in <code>adapters/base.py</code> <pre><code>class Order(TypedDict):\n    \"\"\"\n    Order from the TradeTracer API.\n\n    Passed to `execute_order()`, which dispatches to\n    `execute_buy()` or `execute_sell()`.\n    \"\"\"\n\n    order_id: str\n    action: Literal[\"buy\", \"sell\"]\n    symbol: str\n    volume: int\n    price: float\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter","title":"<code>BaseAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for broker adapters.</p> <p>An adapter is the bridge between the executor and a specific broker. It knows how to connect to the broker, execute buy/sell orders, and optionally fetch real-time quotes. The executor owns the lifecycle \u2014 it calls <code>connect()</code> on start, <code>fetch_quote()</code> and <code>execute_buy()</code>/ <code>execute_sell()</code> during each tick, and <code>disconnect()</code> on stop.</p> <p>Adapters should never raise exceptions for expected failures like insufficient funds or rejected orders. Instead, return a result dict with <code>\"success\": False</code> and an <code>\"error\"</code> message. The executor logs these and continues to the next order.</p> Source code in <code>adapters/base.py</code> <pre><code>class BaseAdapter(ABC):\n    \"\"\"\n    Abstract base class for broker adapters.\n\n    An adapter is the bridge between the executor and a specific broker.\n    It knows how to connect to the broker, execute buy/sell orders, and\n    optionally fetch real-time quotes. The executor owns the lifecycle \u2014\n    it calls `connect()` on start, `fetch_quote()` and `execute_buy()`/\n    `execute_sell()` during each tick, and `disconnect()` on stop.\n\n    Adapters should never raise exceptions for expected failures like\n    insufficient funds or rejected orders. Instead, return a result dict\n    with `\"success\": False` and an `\"error\"` message. The executor logs\n    these and continues to the next order.\n    \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def get_config_fields(cls) -&gt; list[ConfigField]:\n        \"\"\"\n        Return configuration fields for the web UI.\n\n        Called by the web UI when rendering the adapter configuration form.\n        Each field describes one input the user needs to fill in to connect\n        to this broker \u2014 for example, an API key, a hostname, or a port number.\n\n        The web UI dynamically renders form inputs based on these field\n        definitions. When the user saves, the values are stored in\n        `config.json` under `adapter_config` and passed as keyword arguments\n        to the adapter's `__init__()`. The `name` of each field must match\n        an `__init__` parameter name so the value gets passed through.\n\n        Returns:\n            List of field configuration dicts. Each dict has `name`, `label`,\n            `type` (text/password/number/checkbox/select), and optionally\n            `required`, `default`, and `options`.\n\n        Example:\n            ```python\n            @classmethod\n            def get_config_fields(cls):\n                return [\n                    {\n                        \"name\": \"api_key\",\n                        \"label\": \"API Key\",\n                        \"type\": \"password\",\n                        \"required\": True\n                    },\n                    {\n                        \"name\": \"sandbox\",\n                        \"label\": \"Paper Trading\",\n                        \"type\": \"checkbox\",\n                        \"default\": True\n                    },\n                ]\n            ```\n        \"\"\"\n\n    @abstractmethod\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to the broker and verify the session is usable.\n\n        Called exactly once when the user starts the executor. This is where\n        the adapter should establish a network connection, authenticate with\n        credentials, and verify that the session is ready to accept orders.\n\n        If the connection fails \u2014 wrong credentials, broker offline, network\n        error \u2014 return False. The executor will log the failure, stay in the\n        stopped state, and the user can fix their config and try again.\n\n        For adapters that don't need a persistent connection (like the sandbox\n        adapter), this can simply return True.\n\n        Returns:\n            True if the connection was established and the adapter is ready\n            to execute orders. False if something went wrong.\n        \"\"\"\n\n    @abstractmethod\n    def disconnect(self) -&gt; None:\n        \"\"\"\n        Disconnect from the broker and clean up resources.\n\n        Called once when the user stops the executor, or when the container\n        shuts down (via SIGTERM/SIGINT). This is where the adapter should\n        close network connections, cancel any pending requests, and release\n        resources.\n\n        This method should never raise exceptions. If the connection is\n        already closed or was never established, it should silently do nothing.\n        The executor calls this unconditionally during shutdown regardless of\n        the adapter's current state.\n        \"\"\"\n\n    @abstractmethod\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a buy order on the broker.\n\n        Called by the executor when TradeTracer issues a buy order during a\n        tick. The executor receives orders from the TradeTracer API response,\n        then calls this method for each buy order. The adapter should submit\n        the order to the broker and return the fill details.\n\n        The `price` parameter is the ask price that TradeTracer used to size\n        the order. Depending on your broker integration, you can use it as a\n        limit price, a sanity check against slippage, or ignore it entirely\n        and use a market order. The fill price you report back is what\n        TradeTracer records as the actual execution price.\n\n        On success, you must return all four fields: `success`, `fill_price`,\n        `fill_shares`, and `commission`. The executor builds a transaction\n        from these and reports it to TradeTracer on the next tick.\n\n        On failure (insufficient funds, symbol not found, broker rejected the\n        order), return `\"success\": False` with an `\"error\"` message. Do not\n        raise exceptions \u2014 the executor logs the error and moves on to the\n        next order.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n                uppercase, as provided by TradeTracer.\n            shares: Number of shares to buy. Always a positive integer.\n                This is the net consolidated volume from TradeTracer \u2014 if\n                a strategy called `buy(50)` then `sell(20)` in the same\n                tick, you receive `shares=30`.\n            price: The ask price TradeTracer used when generating this\n                order. Use as a limit price or for slippage validation.\n\n        Returns:\n            A dict with `success`, `fill_price`, `fill_shares`, and `commission`\n            on success, or `success` and `error` on failure.\n\n        Example:\n            ```python\n            # Success\n            {\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n            # Failure\n            {\"success\": False, \"error\": \"Insufficient funds\"}\n            ```\n        \"\"\"\n\n    @abstractmethod\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a sell order on the broker.\n\n        Called by the executor when TradeTracer issues a sell order during a\n        tick. Behaves identically to `execute_buy()` but for the sell side.\n\n        The `price` parameter is the bid price that TradeTracer used to\n        calculate expected proceeds. As with buys, you can use it as a limit,\n        a sanity check, or ignore it.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n                uppercase, as provided by TradeTracer.\n            shares: Number of shares to sell. Always a positive integer.\n                The executor only sends sell orders for positions the strategy\n                holds, but the adapter should still validate against its own\n                position tracking in case of desync.\n            price: The bid price TradeTracer used when generating this\n                order. Use as a limit price or for slippage validation.\n\n        Returns:\n            Same format as `execute_buy()` \u2014 a dict with `success`, `fill_price`,\n            `fill_shares`, and `commission` on success, or `success` and `error`\n            on failure.\n        \"\"\"\n\n    @abstractmethod\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        \"\"\"\n        Fetch a price quote for a symbol.\n\n        Called by the executor at the start of every tick, once per tracked\n        symbol. The executor sends the returned quotes to TradeTracer, which\n        uses them for intraday strategy evaluation and order pricing.\n\n        The `eod_last_price` is the most recent end-of-day close price from\n        TradeTracer's data. Adapters can use it however they need \u2014 for\n        example, the sandbox adapter uses it to simulate intraday price\n        movement via random walk. Broker adapters like IBKR can ignore it\n        and fetch real-time data from the broker instead.\n\n        The EOD price also serves as a sanity check \u2014 users can compare\n        their broker's price against TradeTracer's data to verify accuracy.\n        TradeTracer's data is not always correct, and this transparency\n        helps users catch discrepancies.\n\n        Args:\n            symbol: Stock ticker symbol (e.g., `\"AAPL\"`). Always uppercase.\n            eod_last_price: Last known EOD close price from TradeTracer,\n                or None if not yet available (first tick).\n\n        Returns:\n            A Quote dict with price fields, or None if unavailable.\n\n        Example:\n            ```python\n            # Broker adapter \u2014 fetch real data, ignore EOD\n            def fetch_quote(self, symbol, eod_last_price):\n                ticker = self.client.get_ticker(symbol)\n                return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n            # Sandbox adapter \u2014 simulate from EOD\n            def fetch_quote(self, symbol, eod_last_price):\n                if not eod_last_price:\n                    return None\n                price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n                return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n            ```\n        \"\"\"\n\n    def execute_order(self, order: Order) -&gt; FillResult:\n        \"\"\"\n        Dispatch an order from TradeTracer to the appropriate handler.\n\n        This is the method the executor loop actually calls. It reads the\n        `action` field from the order dict and routes to `execute_buy()` or\n        `execute_sell()`. You do not need to override this method \u2014 it\n        exists as a convenience so the executor doesn't need to branch on\n        order type itself.\n\n        The order dict comes directly from the TradeTracer API response.\n        Each order represents a consolidated net trade for one symbol from\n        one worker during one tick. TradeTracer handles consolidation \u2014 if\n        a strategy called `buy(50)` then `sell(20)`, you receive a single\n        order with `action: \"buy\"` and `volume: 30`.\n\n        Args:\n            order: Order dict from the TradeTracer API response with keys:\n\n                - `action` (str): `\"buy\"` or `\"sell\"`.\n                - `symbol` (str): Stock ticker symbol, uppercase.\n                - `volume` (int): Number of shares (always positive).\n                - `price` (float): Ask price for buys, bid price for sells.\n                - `order_id` (str): UUID that links this order to the\n                  transaction reported back on the next tick.\n\n        Returns:\n            The result dict from `execute_buy()` or `execute_sell()`.\n\n        Example:\n            ```python\n            order = {\n                \"action\": \"buy\",\n                \"symbol\": \"AAPL\",\n                \"volume\": 100,\n                \"price\": 186.50,\n                \"order_id\": \"abc-123\"\n            }\n            result = adapter.execute_order(order)\n            ```\n        \"\"\"\n        if order[\"action\"] == \"buy\":\n            return self.execute_buy(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n        else:\n            return self.execute_sell(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.get_config_fields","title":"<code>get_config_fields()</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Return configuration fields for the web UI.</p> <p>Called by the web UI when rendering the adapter configuration form. Each field describes one input the user needs to fill in to connect to this broker \u2014 for example, an API key, a hostname, or a port number.</p> <p>The web UI dynamically renders form inputs based on these field definitions. When the user saves, the values are stored in <code>config.json</code> under <code>adapter_config</code> and passed as keyword arguments to the adapter's <code>__init__()</code>. The <code>name</code> of each field must match an <code>__init__</code> parameter name so the value gets passed through.</p> <p>Returns:</p> Type Description <code>list[ConfigField]</code> <p>List of field configuration dicts. Each dict has <code>name</code>, <code>label</code>, <code>type</code> (text/password/number/checkbox/select), and optionally <code>required</code>, <code>default</code>, and <code>options</code>.</p> Example <pre><code>@classmethod\ndef get_config_fields(cls):\n    return [\n        {\n            \"name\": \"api_key\",\n            \"label\": \"API Key\",\n            \"type\": \"password\",\n            \"required\": True\n        },\n        {\n            \"name\": \"sandbox\",\n            \"label\": \"Paper Trading\",\n            \"type\": \"checkbox\",\n            \"default\": True\n        },\n    ]\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_config_fields(cls) -&gt; list[ConfigField]:\n    \"\"\"\n    Return configuration fields for the web UI.\n\n    Called by the web UI when rendering the adapter configuration form.\n    Each field describes one input the user needs to fill in to connect\n    to this broker \u2014 for example, an API key, a hostname, or a port number.\n\n    The web UI dynamically renders form inputs based on these field\n    definitions. When the user saves, the values are stored in\n    `config.json` under `adapter_config` and passed as keyword arguments\n    to the adapter's `__init__()`. The `name` of each field must match\n    an `__init__` parameter name so the value gets passed through.\n\n    Returns:\n        List of field configuration dicts. Each dict has `name`, `label`,\n        `type` (text/password/number/checkbox/select), and optionally\n        `required`, `default`, and `options`.\n\n    Example:\n        ```python\n        @classmethod\n        def get_config_fields(cls):\n            return [\n                {\n                    \"name\": \"api_key\",\n                    \"label\": \"API Key\",\n                    \"type\": \"password\",\n                    \"required\": True\n                },\n                {\n                    \"name\": \"sandbox\",\n                    \"label\": \"Paper Trading\",\n                    \"type\": \"checkbox\",\n                    \"default\": True\n                },\n            ]\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.connect","title":"<code>connect()</code>  <code>abstractmethod</code>","text":"<p>Connect to the broker and verify the session is usable.</p> <p>Called exactly once when the user starts the executor. This is where the adapter should establish a network connection, authenticate with credentials, and verify that the session is ready to accept orders.</p> <p>If the connection fails \u2014 wrong credentials, broker offline, network error \u2014 return False. The executor will log the failure, stay in the stopped state, and the user can fix their config and try again.</p> <p>For adapters that don't need a persistent connection (like the sandbox adapter), this can simply return True.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the connection was established and the adapter is ready to execute orders. False if something went wrong.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef connect(self) -&gt; bool:\n    \"\"\"\n    Connect to the broker and verify the session is usable.\n\n    Called exactly once when the user starts the executor. This is where\n    the adapter should establish a network connection, authenticate with\n    credentials, and verify that the session is ready to accept orders.\n\n    If the connection fails \u2014 wrong credentials, broker offline, network\n    error \u2014 return False. The executor will log the failure, stay in the\n    stopped state, and the user can fix their config and try again.\n\n    For adapters that don't need a persistent connection (like the sandbox\n    adapter), this can simply return True.\n\n    Returns:\n        True if the connection was established and the adapter is ready\n        to execute orders. False if something went wrong.\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code>","text":"<p>Disconnect from the broker and clean up resources.</p> <p>Called once when the user stops the executor, or when the container shuts down (via SIGTERM/SIGINT). This is where the adapter should close network connections, cancel any pending requests, and release resources.</p> <p>This method should never raise exceptions. If the connection is already closed or was never established, it should silently do nothing. The executor calls this unconditionally during shutdown regardless of the adapter's current state.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef disconnect(self) -&gt; None:\n    \"\"\"\n    Disconnect from the broker and clean up resources.\n\n    Called once when the user stops the executor, or when the container\n    shuts down (via SIGTERM/SIGINT). This is where the adapter should\n    close network connections, cancel any pending requests, and release\n    resources.\n\n    This method should never raise exceptions. If the connection is\n    already closed or was never established, it should silently do nothing.\n    The executor calls this unconditionally during shutdown regardless of\n    the adapter's current state.\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.execute_buy","title":"<code>execute_buy(symbol, shares, price)</code>  <code>abstractmethod</code>","text":"<p>Execute a buy order on the broker.</p> <p>Called by the executor when TradeTracer issues a buy order during a tick. The executor receives orders from the TradeTracer API response, then calls this method for each buy order. The adapter should submit the order to the broker and return the fill details.</p> <p>The <code>price</code> parameter is the ask price that TradeTracer used to size the order. Depending on your broker integration, you can use it as a limit price, a sanity check against slippage, or ignore it entirely and use a market order. The fill price you report back is what TradeTracer records as the actual execution price.</p> <p>On success, you must return all four fields: <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code>. The executor builds a transaction from these and reports it to TradeTracer on the next tick.</p> <p>On failure (insufficient funds, symbol not found, broker rejected the order), return <code>\"success\": False</code> with an <code>\"error\"</code> message. Do not raise exceptions \u2014 the executor logs the error and moves on to the next order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>, <code>\"TSLA\"</code>). Always uppercase, as provided by TradeTracer.</p> required <code>shares</code> <code>int</code> <p>Number of shares to buy. Always a positive integer. This is the net consolidated volume from TradeTracer \u2014 if a strategy called <code>buy(50)</code> then <code>sell(20)</code> in the same tick, you receive <code>shares=30</code>.</p> required <code>price</code> <code>float</code> <p>The ask price TradeTracer used when generating this order. Use as a limit price or for slippage validation.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>A dict with <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> on success, or <code>success</code> and <code>error</code> on failure.</p> Example <pre><code># Success\n{\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n# Failure\n{\"success\": False, \"error\": \"Insufficient funds\"}\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a buy order on the broker.\n\n    Called by the executor when TradeTracer issues a buy order during a\n    tick. The executor receives orders from the TradeTracer API response,\n    then calls this method for each buy order. The adapter should submit\n    the order to the broker and return the fill details.\n\n    The `price` parameter is the ask price that TradeTracer used to size\n    the order. Depending on your broker integration, you can use it as a\n    limit price, a sanity check against slippage, or ignore it entirely\n    and use a market order. The fill price you report back is what\n    TradeTracer records as the actual execution price.\n\n    On success, you must return all four fields: `success`, `fill_price`,\n    `fill_shares`, and `commission`. The executor builds a transaction\n    from these and reports it to TradeTracer on the next tick.\n\n    On failure (insufficient funds, symbol not found, broker rejected the\n    order), return `\"success\": False` with an `\"error\"` message. Do not\n    raise exceptions \u2014 the executor logs the error and moves on to the\n    next order.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n            uppercase, as provided by TradeTracer.\n        shares: Number of shares to buy. Always a positive integer.\n            This is the net consolidated volume from TradeTracer \u2014 if\n            a strategy called `buy(50)` then `sell(20)` in the same\n            tick, you receive `shares=30`.\n        price: The ask price TradeTracer used when generating this\n            order. Use as a limit price or for slippage validation.\n\n    Returns:\n        A dict with `success`, `fill_price`, `fill_shares`, and `commission`\n        on success, or `success` and `error` on failure.\n\n    Example:\n        ```python\n        # Success\n        {\"success\": True, \"fill_price\": 186.50, \"fill_shares\": 100, \"commission\": 1.00}\n\n        # Failure\n        {\"success\": False, \"error\": \"Insufficient funds\"}\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.execute_sell","title":"<code>execute_sell(symbol, shares, price)</code>  <code>abstractmethod</code>","text":"<p>Execute a sell order on the broker.</p> <p>Called by the executor when TradeTracer issues a sell order during a tick. Behaves identically to <code>execute_buy()</code> but for the sell side.</p> <p>The <code>price</code> parameter is the bid price that TradeTracer used to calculate expected proceeds. As with buys, you can use it as a limit, a sanity check, or ignore it.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>, <code>\"TSLA\"</code>). Always uppercase, as provided by TradeTracer.</p> required <code>shares</code> <code>int</code> <p>Number of shares to sell. Always a positive integer. The executor only sends sell orders for positions the strategy holds, but the adapter should still validate against its own position tracking in case of desync.</p> required <code>price</code> <code>float</code> <p>The bid price TradeTracer used when generating this order. Use as a limit price or for slippage validation.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Same format as <code>execute_buy()</code> \u2014 a dict with <code>success</code>, <code>fill_price</code>, <code>fill_shares</code>, and <code>commission</code> on success, or <code>success</code> and <code>error</code> on failure.</p> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a sell order on the broker.\n\n    Called by the executor when TradeTracer issues a sell order during a\n    tick. Behaves identically to `execute_buy()` but for the sell side.\n\n    The `price` parameter is the bid price that TradeTracer used to\n    calculate expected proceeds. As with buys, you can use it as a limit,\n    a sanity check, or ignore it.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`, `\"TSLA\"`). Always\n            uppercase, as provided by TradeTracer.\n        shares: Number of shares to sell. Always a positive integer.\n            The executor only sends sell orders for positions the strategy\n            holds, but the adapter should still validate against its own\n            position tracking in case of desync.\n        price: The bid price TradeTracer used when generating this\n            order. Use as a limit price or for slippage validation.\n\n    Returns:\n        Same format as `execute_buy()` \u2014 a dict with `success`, `fill_price`,\n        `fill_shares`, and `commission` on success, or `success` and `error`\n        on failure.\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.fetch_quote","title":"<code>fetch_quote(symbol, eod_last_price)</code>  <code>abstractmethod</code>","text":"<p>Fetch a price quote for a symbol.</p> <p>Called by the executor at the start of every tick, once per tracked symbol. The executor sends the returned quotes to TradeTracer, which uses them for intraday strategy evaluation and order pricing.</p> <p>The <code>eod_last_price</code> is the most recent end-of-day close price from TradeTracer's data. Adapters can use it however they need \u2014 for example, the sandbox adapter uses it to simulate intraday price movement via random walk. Broker adapters like IBKR can ignore it and fetch real-time data from the broker instead.</p> <p>The EOD price also serves as a sanity check \u2014 users can compare their broker's price against TradeTracer's data to verify accuracy. TradeTracer's data is not always correct, and this transparency helps users catch discrepancies.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., <code>\"AAPL\"</code>). Always uppercase.</p> required <code>eod_last_price</code> <code>float | None</code> <p>Last known EOD close price from TradeTracer, or None if not yet available (first tick).</p> required <p>Returns:</p> Type Description <code>Quote | None</code> <p>A Quote dict with price fields, or None if unavailable.</p> Example <pre><code># Broker adapter \u2014 fetch real data, ignore EOD\ndef fetch_quote(self, symbol, eod_last_price):\n    ticker = self.client.get_ticker(symbol)\n    return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n# Sandbox adapter \u2014 simulate from EOD\ndef fetch_quote(self, symbol, eod_last_price):\n    if not eod_last_price:\n        return None\n    price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n    return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>@abstractmethod\ndef fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n    \"\"\"\n    Fetch a price quote for a symbol.\n\n    Called by the executor at the start of every tick, once per tracked\n    symbol. The executor sends the returned quotes to TradeTracer, which\n    uses them for intraday strategy evaluation and order pricing.\n\n    The `eod_last_price` is the most recent end-of-day close price from\n    TradeTracer's data. Adapters can use it however they need \u2014 for\n    example, the sandbox adapter uses it to simulate intraday price\n    movement via random walk. Broker adapters like IBKR can ignore it\n    and fetch real-time data from the broker instead.\n\n    The EOD price also serves as a sanity check \u2014 users can compare\n    their broker's price against TradeTracer's data to verify accuracy.\n    TradeTracer's data is not always correct, and this transparency\n    helps users catch discrepancies.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., `\"AAPL\"`). Always uppercase.\n        eod_last_price: Last known EOD close price from TradeTracer,\n            or None if not yet available (first tick).\n\n    Returns:\n        A Quote dict with price fields, or None if unavailable.\n\n    Example:\n        ```python\n        # Broker adapter \u2014 fetch real data, ignore EOD\n        def fetch_quote(self, symbol, eod_last_price):\n            ticker = self.client.get_ticker(symbol)\n            return {\"close\": ticker.last, \"bid\": ticker.bid, \"ask\": ticker.ask}\n\n        # Sandbox adapter \u2014 simulate from EOD\n        def fetch_quote(self, symbol, eod_last_price):\n            if not eod_last_price:\n                return None\n            price = eod_last_price * (1 + random.uniform(-0.005, 0.005))\n            return {\"close\": price, \"bid\": price - 0.01, \"ask\": price + 0.01}\n        ```\n    \"\"\"\n</code></pre>"},{"location":"reference/base-adapter/#adapters.base.BaseAdapter.execute_order","title":"<code>execute_order(order)</code>","text":"<p>Dispatch an order from TradeTracer to the appropriate handler.</p> <p>This is the method the executor loop actually calls. It reads the <code>action</code> field from the order dict and routes to <code>execute_buy()</code> or <code>execute_sell()</code>. You do not need to override this method \u2014 it exists as a convenience so the executor doesn't need to branch on order type itself.</p> <p>The order dict comes directly from the TradeTracer API response. Each order represents a consolidated net trade for one symbol from one worker during one tick. TradeTracer handles consolidation \u2014 if a strategy called <code>buy(50)</code> then <code>sell(20)</code>, you receive a single order with <code>action: \"buy\"</code> and <code>volume: 30</code>.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>Order</code> <p>Order dict from the TradeTracer API response with keys:</p> <ul> <li><code>action</code> (str): <code>\"buy\"</code> or <code>\"sell\"</code>.</li> <li><code>symbol</code> (str): Stock ticker symbol, uppercase.</li> <li><code>volume</code> (int): Number of shares (always positive).</li> <li><code>price</code> (float): Ask price for buys, bid price for sells.</li> <li><code>order_id</code> (str): UUID that links this order to the   transaction reported back on the next tick.</li> </ul> required <p>Returns:</p> Type Description <code>FillResult</code> <p>The result dict from <code>execute_buy()</code> or <code>execute_sell()</code>.</p> Example <pre><code>order = {\n    \"action\": \"buy\",\n    \"symbol\": \"AAPL\",\n    \"volume\": 100,\n    \"price\": 186.50,\n    \"order_id\": \"abc-123\"\n}\nresult = adapter.execute_order(order)\n</code></pre> Source code in <code>adapters/base.py</code> <pre><code>def execute_order(self, order: Order) -&gt; FillResult:\n    \"\"\"\n    Dispatch an order from TradeTracer to the appropriate handler.\n\n    This is the method the executor loop actually calls. It reads the\n    `action` field from the order dict and routes to `execute_buy()` or\n    `execute_sell()`. You do not need to override this method \u2014 it\n    exists as a convenience so the executor doesn't need to branch on\n    order type itself.\n\n    The order dict comes directly from the TradeTracer API response.\n    Each order represents a consolidated net trade for one symbol from\n    one worker during one tick. TradeTracer handles consolidation \u2014 if\n    a strategy called `buy(50)` then `sell(20)`, you receive a single\n    order with `action: \"buy\"` and `volume: 30`.\n\n    Args:\n        order: Order dict from the TradeTracer API response with keys:\n\n            - `action` (str): `\"buy\"` or `\"sell\"`.\n            - `symbol` (str): Stock ticker symbol, uppercase.\n            - `volume` (int): Number of shares (always positive).\n            - `price` (float): Ask price for buys, bid price for sells.\n            - `order_id` (str): UUID that links this order to the\n              transaction reported back on the next tick.\n\n    Returns:\n        The result dict from `execute_buy()` or `execute_sell()`.\n\n    Example:\n        ```python\n        order = {\n            \"action\": \"buy\",\n            \"symbol\": \"AAPL\",\n            \"volume\": 100,\n            \"price\": 186.50,\n            \"order_id\": \"abc-123\"\n        }\n        result = adapter.execute_order(order)\n        ```\n    \"\"\"\n    if order[\"action\"] == \"buy\":\n        return self.execute_buy(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n    else:\n        return self.execute_sell(order[\"symbol\"], order[\"volume\"], order[\"price\"])\n</code></pre>"},{"location":"reference/config/","title":"Configuration","text":"<p>Configuration loading and management.</p>"},{"location":"reference/config/#executor.config","title":"<code>config</code>","text":"<p>Configuration management for TradeTracer Executor.</p> <p>Handles loading and saving configuration from JSON files. The config file is stored in the data directory (mounted as /data in Docker).</p> Example <pre><code>from executor.config import Config\n\n# Load existing config\nconfig = Config.load(\"/data/config.json\")\n\n# Create and save new config\nconfig = Config(\n    api_key=\"your-api-key\",\n    adapter=\"sandbox\",\n)\nconfig.save(\"/data/config.json\")\n</code></pre>"},{"location":"reference/config/#executor.config.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Executor configuration.</p> <p>Attributes:</p> Name Type Description <code>api_key</code> <code>str</code> <p>TradeTracer API key for authentication.</p> <code>adapter</code> <code>str</code> <p>Adapter type (e.g., \"sandbox\", \"ibkr\").</p> <code>adapter_config</code> <code>dict[str, Any]</code> <p>Adapter-specific configuration.</p> <code>api_url</code> <code>str</code> <p>TradeTracer API base URL.</p> <code>poll_interval</code> <code>int</code> <p>Seconds between ticks.</p> <code>data_path</code> <code>str</code> <p>Path to data directory.</p> Source code in <code>executor/config.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Executor configuration.\n\n    Attributes:\n        api_key: TradeTracer API key for authentication.\n        adapter: Adapter type (e.g., \"sandbox\", \"ibkr\").\n        adapter_config: Adapter-specific configuration.\n        api_url: TradeTracer API base URL.\n        poll_interval: Seconds between ticks.\n        data_path: Path to data directory.\n    \"\"\"\n\n    api_key: str = \"\"\n    adapter: str = \"sandbox\"\n    adapter_config: dict[str, Any] = field(default_factory=dict)\n    api_url: str = DEFAULT_API_URL\n    poll_interval: int = DEFAULT_POLL_INTERVAL\n    data_path: str = \"/data\"\n\n    def save(self, path: str | Path) -&gt; None:\n        \"\"\"\n        Save configuration to JSON file.\n\n        Args:\n            path: Path to config file.\n\n        Example:\n            ```python\n            config.save(\"/data/config.json\")\n            ```\n        \"\"\"\n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        path.write_text(json.dumps(asdict(self), indent=2))\n\n    @classmethod\n    def load(cls, path: str | Path) -&gt; \"Config\":\n        \"\"\"\n        Load configuration from JSON file.\n\n        If file doesn't exist, returns default config.\n\n        Args:\n            path: Path to config file.\n\n        Returns:\n            Loaded or default Config instance.\n\n        Example:\n            ```python\n            config = Config.load(\"/data/config.json\")\n            ```\n        \"\"\"\n        path = Path(path)\n        if not path.exists():\n            return cls()\n\n        data = json.loads(path.read_text())\n        return cls(\n            api_key=data.get(\"api_key\", \"\"),\n            adapter=data.get(\"adapter\", \"sandbox\"),\n            adapter_config=data.get(\"adapter_config\", {}),\n            api_url=data.get(\"api_url\", DEFAULT_API_URL),\n            poll_interval=data.get(\"poll_interval\", DEFAULT_POLL_INTERVAL),\n            data_path=data.get(\"data_path\", \"/data\"),\n        )\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"\n        Check if config has required fields.\n\n        Returns:\n            True if api_key is set.\n        \"\"\"\n        return bool(self.api_key)\n\n    def get_tick_url(self) -&gt; str:\n        \"\"\"\n        Get full URL for tick endpoint.\n\n        Returns:\n            URL like \"https://tradetracer.ai/api/models/tick\".\n        \"\"\"\n        return f\"{self.api_url}/api/llmapi/models/tick\"\n</code></pre>"},{"location":"reference/config/#executor.config.Config.save","title":"<code>save(path)</code>","text":"<p>Save configuration to JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to config file.</p> required Example <pre><code>config.save(\"/data/config.json\")\n</code></pre> Source code in <code>executor/config.py</code> <pre><code>def save(self, path: str | Path) -&gt; None:\n    \"\"\"\n    Save configuration to JSON file.\n\n    Args:\n        path: Path to config file.\n\n    Example:\n        ```python\n        config.save(\"/data/config.json\")\n        ```\n    \"\"\"\n    path = Path(path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(json.dumps(asdict(self), indent=2))\n</code></pre>"},{"location":"reference/config/#executor.config.Config.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>Load configuration from JSON file.</p> <p>If file doesn't exist, returns default config.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to config file.</p> required <p>Returns:</p> Type Description <code>Config</code> <p>Loaded or default Config instance.</p> Example <pre><code>config = Config.load(\"/data/config.json\")\n</code></pre> Source code in <code>executor/config.py</code> <pre><code>@classmethod\ndef load(cls, path: str | Path) -&gt; \"Config\":\n    \"\"\"\n    Load configuration from JSON file.\n\n    If file doesn't exist, returns default config.\n\n    Args:\n        path: Path to config file.\n\n    Returns:\n        Loaded or default Config instance.\n\n    Example:\n        ```python\n        config = Config.load(\"/data/config.json\")\n        ```\n    \"\"\"\n    path = Path(path)\n    if not path.exists():\n        return cls()\n\n    data = json.loads(path.read_text())\n    return cls(\n        api_key=data.get(\"api_key\", \"\"),\n        adapter=data.get(\"adapter\", \"sandbox\"),\n        adapter_config=data.get(\"adapter_config\", {}),\n        api_url=data.get(\"api_url\", DEFAULT_API_URL),\n        poll_interval=data.get(\"poll_interval\", DEFAULT_POLL_INTERVAL),\n        data_path=data.get(\"data_path\", \"/data\"),\n    )\n</code></pre>"},{"location":"reference/config/#executor.config.Config.is_valid","title":"<code>is_valid()</code>","text":"<p>Check if config has required fields.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if api_key is set.</p> Source code in <code>executor/config.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"\n    Check if config has required fields.\n\n    Returns:\n        True if api_key is set.\n    \"\"\"\n    return bool(self.api_key)\n</code></pre>"},{"location":"reference/config/#executor.config.Config.get_tick_url","title":"<code>get_tick_url()</code>","text":"<p>Get full URL for tick endpoint.</p> <p>Returns:</p> Type Description <code>str</code> <p>URL like \"https://tradetracer.ai/api/models/tick\".</p> Source code in <code>executor/config.py</code> <pre><code>def get_tick_url(self) -&gt; str:\n    \"\"\"\n    Get full URL for tick endpoint.\n\n    Returns:\n        URL like \"https://tradetracer.ai/api/models/tick\".\n    \"\"\"\n    return f\"{self.api_url}/api/llmapi/models/tick\"\n</code></pre>"},{"location":"reference/executor/","title":"Main Loop","text":"<p>Core executor that connects TradeTracer to your broker.</p>"},{"location":"reference/executor/#executor.main","title":"<code>main</code>","text":"<p>Main executor loop for TradeTracer.</p> <p>This module contains the core execution loop that: 1. Calls TradeTracer's /tick endpoint with pending transactions 2. Receives orders to execute 3. Executes orders via the configured adapter 4. Stores fills for the next tick</p> Example <pre><code>from executor.main import Executor\n\nexecutor = Executor(\"/data/config.json\")\nexecutor.run()  # Blocks, runs until stopped\n</code></pre> <p>Or run directly: <pre><code>python -m executor.main\n</code></pre></p>"},{"location":"reference/executor/#executor.main.Executor","title":"<code>Executor</code>","text":"<p>Main executor that connects TradeTracer to a broker.</p> <p>Runs a loop that: 1. Reports pending transactions to TradeTracer 2. Receives orders from TradeTracer 3. Executes orders via broker adapter 4. Stores fills for next tick</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>Executor configuration.</p> <code>adapter</code> <code>BaseAdapter | None</code> <p>Broker adapter for order execution.</p> <code>transactions</code> <p>Pending transactions to report on next tick.</p> <code>running</code> <p>Whether the executor is running.</p> Source code in <code>executor/main.py</code> <pre><code>class Executor:\n    \"\"\"\n    Main executor that connects TradeTracer to a broker.\n\n    Runs a loop that:\n    1. Reports pending transactions to TradeTracer\n    2. Receives orders from TradeTracer\n    3. Executes orders via broker adapter\n    4. Stores fills for next tick\n\n    Attributes:\n        config: Executor configuration.\n        adapter: Broker adapter for order execution.\n        transactions: Pending transactions to report on next tick.\n        running: Whether the executor is running.\n    \"\"\"\n\n    def __init__(self, config_path: str | Path = \"/data/config.json\"):\n        \"\"\"\n        Initialize executor.\n\n        Args:\n            config_path: Path to configuration file.\n        \"\"\"\n        self.config_path = Path(config_path)\n        self.config = Config.load(self.config_path)\n        self.transactions = TransactionStore(self.config.data_path)\n        self.adapter: BaseAdapter | None = None\n        self.running = False\n\n        # Track stats\n        self.tick_count = 0\n        self.last_tick_time: float | None = None\n        self.error_count = 0\n        self.last_error: str | None = None\n\n        # Tracked symbols and their EOD prices (from previous tick response)\n        self.symbols: list[str] = []\n        self.eod_prices: dict[str, float] = {}\n\n        # Strategy logs per worker\n        self.strategy_logs: dict[str, list] = {}\n\n    def start(self) -&gt; str | None:\n        \"\"\"\n        Start the executor.\n\n        Validates config and connects to broker.\n\n        Returns:\n            None if started successfully, error message string otherwise.\n        \"\"\"\n        # Validate config\n        if not self.config.is_valid():\n            msg = \"Invalid config: API key is required\"\n            logger.error(msg)\n            return msg\n\n        # Create and connect adapter\n        adapter_name = self.config.adapter\n        try:\n            self.adapter = get_adapter(adapter_name, self.config.adapter_config)\n            if not self.adapter.connect():\n                msg = f\"{adapter_name}: failed to connect\"\n                logger.error(msg)\n                return msg\n        except Exception as e:\n            msg = f\"{adapter_name}: {e}\"\n            logger.error(msg)\n            return msg\n\n        logger.info(f\"Connected to {adapter_name} adapter\")\n        logger.info(f\"Poll interval: {self.config.poll_interval}s\")\n\n        self.running = True\n        return None\n\n    def stop(self) -&gt; None:\n        \"\"\"Stop the executor and disconnect from broker.\"\"\"\n        self.running = False\n        if self.adapter:\n            self.adapter.disconnect()\n            logger.info(\"Disconnected from adapter\")\n\n    def tick(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Execute one tick cycle.\n\n        1. Get pending transactions\n        2. Fetch quotes for tracked symbols\n        3. Call TradeTracer /tick endpoint with prices + transactions\n        4. Execute returned orders\n        5. Store fills and symbols for next tick\n\n        Returns:\n            Result dict with tick details.\n        \"\"\"\n        assert self.adapter is not None\n\n        tick_start = time.time()\n        self.tick_count += 1\n        self.last_tick_time = time.time()\n\n        # 1. Get pending transactions to report\n        pending = self.transactions.get_pending()\n        logger.info(f\"Tick {self.tick_count}: {len(pending)} pending transactions\")\n\n        # 2. Fetch quotes for tracked symbols\n        prices: dict[str, Any] = {}\n        for symbol in self.symbols:\n            eod = self.eod_prices.get(symbol)\n            try:\n                quote = self.adapter.fetch_quote(symbol, eod)\n            except Exception as e:\n                logger.warning(f\"{self.config.adapter}: {symbol} fetch_quote failed: {e}\")\n                continue\n            if quote:\n                prices[symbol] = {\n                    \"ohlcv\": {\n                        \"o\": quote.get(\"open\"),\n                        \"h\": quote.get(\"high\"),\n                        \"l\": quote.get(\"low\"),\n                        \"c\": quote.get(\"close\"),\n                        \"v\": quote.get(\"volume\"),\n                    },\n                    \"bid\": quote.get(\"bid\"),\n                    \"ask\": quote.get(\"ask\"),\n                    \"time\": int(time.time()),\n                }\n                logger.debug(f\"Quote {symbol}: {quote.get('close', 'N/A')}\")\n\n        # 3. Call TradeTracer /tick endpoint (hard 5s timeout)\n        def _post():\n            return requests.post(\n                self.config.get_tick_url(),\n                headers={\"Authorization\": f\"Bearer {self.config.api_key}\"},\n                json={\"prices\": prices, \"transactions\": pending},\n                timeout=5,\n            )\n\n        pool = ThreadPoolExecutor(max_workers=1)\n        future = pool.submit(_post)\n        try:\n            response = future.result(timeout=5)\n        except FuturesTimeout:\n            pool.shutdown(wait=False, cancel_futures=True)\n            error_msg = f\"Timeout: {self.config.get_tick_url()} did not respond in 5s\"\n            logger.error(error_msg)\n            self.error_count += 1\n            self.last_error = error_msg\n            return {\"success\": False, \"error\": error_msg}\n        except Exception as e:\n            pool.shutdown(wait=False, cancel_futures=True)\n            error_msg = f\"{type(e).__name__}: {e}\"\n            logger.error(f\"Tick failed: {error_msg}\")\n            self.error_count += 1\n            self.last_error = error_msg\n            return {\"success\": False, \"error\": error_msg}\n        else:\n            pool.shutdown(wait=False)\n\n        if not response.ok:\n            # Parse error detail from response body\n            detail = \"\"\n            try:\n                body = response.json()\n                if isinstance(body, dict):\n                    detail = body.get(\"detail\") or body.get(\"error\") or \"\"\n                if isinstance(detail, dict):\n                    detail = detail.get(\"error\", str(detail))\n            except Exception:\n                detail = response.text[:200]\n            error_msg = f\"{response.status_code}: {detail}\" if detail else f\"{response.status_code}\"\n            logger.error(f\"Tick failed: {error_msg}\")\n            self.error_count += 1\n            self.last_error = error_msg\n            return {\"success\": False, \"error\": error_msg}\n\n        # 4. Clear reported transactions\n        self.transactions.clear()\n\n        # 5. Process response\n        data = response.json()\n        orders = data.get(\"orders\", [])\n\n        # 6. Update tracked symbols and EOD prices from response\n        self.eod_prices = data.get(\"prices\", {})\n        self.symbols = list(self.eod_prices.keys())\n        logger.info(f\"Received {len(orders)} orders, tracking {len(self.symbols)} symbols\")\n\n        # 7. Capture strategy logs per worker\n        from datetime import datetime\n        ts = datetime.now().strftime(\"%I:%M:%S %p\")\n        logs = data.get(\"logs\", {})\n        for symbol, lines in logs.items():\n            if symbol not in self.strategy_logs:\n                self.strategy_logs[symbol] = []\n            for line in lines:\n                self.strategy_logs[symbol].append(f\"{ts} {line}\")\n            # Keep last 200\n            if len(self.strategy_logs[symbol]) &gt; 200:\n                self.strategy_logs[symbol] = self.strategy_logs[symbol][-200:]\n\n        # 8. Execute orders\n        new_transactions = []\n        for order in orders:\n            logger.info(\n                f\"Executing: {order['action'].upper()} \"\n                f\"{order['symbol']} x{order['volume']} @ {order['price']}\"\n            )\n\n            result = self.adapter.execute_order(order)\n\n            if result[\"success\"]:\n                tx = {\n                    \"order_id\": order[\"order_id\"],\n                    \"symbol\": order[\"symbol\"],\n                    \"action\": order[\"action\"],\n                    \"volume\": result[\"fill_shares\"],\n                    \"price\": result[\"fill_price\"],\n                    \"commission\": result[\"commission\"],\n                    \"time\": int(time.time()),\n                }\n                new_transactions.append(tx)\n                logger.info(\n                    f\"  Filled: {result['fill_shares']} @ ${result['fill_price']:.2f}\"\n                )\n            else:\n                logger.warning(f\"  {self.config.adapter}: {order['symbol']} {order['action']} failed: {result.get('error', 'Unknown error')}\")\n\n        # 9. Store new transactions for next tick\n        self.transactions.add(new_transactions)\n\n        tick_duration = time.time() - tick_start\n\n        return {\n            \"success\": True,\n            \"tick\": self.tick_count,\n            \"orders_received\": len(orders),\n            \"orders_filled\": len(new_transactions),\n            \"duration_ms\": int(tick_duration * 1000),\n        }\n\n    def run(self) -&gt; None:\n        \"\"\"\n        Run the executor loop.\n\n        Blocks until stopped via signal or stop() call.\n        Handles SIGINT and SIGTERM for graceful shutdown.\n        \"\"\"\n\n        # Setup signal handlers\n        def handle_signal(signum: int, frame: Any) -&gt; None:\n            logger.info(\"Shutdown signal received\")\n            self.stop()\n\n        signal.signal(signal.SIGINT, handle_signal)\n        signal.signal(signal.SIGTERM, handle_signal)\n\n        # Start\n        error = self.start()\n        if error:\n            logger.error(f\"Failed to start executor: {error}\")\n            sys.exit(1)\n\n        logger.info(\"Executor started, entering main loop\")\n\n        # Main loop\n        while self.running:\n            try:\n                result = self.tick()\n                if result[\"success\"]:\n                    logger.info(\n                        f\"Tick complete: {result['orders_filled']}/{result['orders_received']} \"\n                        f\"orders filled in {result['duration_ms']}ms\"\n                    )\n            except Exception as e:\n                logger.error(f\"Tick error: {e}\")\n\n            # Wait for next tick\n            if self.running:\n                time.sleep(self.config.poll_interval)\n\n        logger.info(\"Executor stopped\")\n\n    def get_status(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get executor status.\n\n        Returns:\n            Status dict with running state, tick count, etc.\n        \"\"\"\n        # Build worker info per symbol\n        workers = {}\n        for symbol in self.symbols:\n            workers[symbol] = {\n                \"price\": self.eod_prices.get(symbol),\n                \"logs\": list(self.strategy_logs.get(symbol, [])),\n            }\n\n        return {\n            \"running\": self.running,\n            \"tick_count\": self.tick_count,\n            \"last_tick_time\": self.last_tick_time,\n            \"pending_transactions\": self.transactions.count(),\n            \"config_valid\": self.config.is_valid(),\n            \"adapter\": self.config.adapter,\n            \"error_count\": self.error_count,\n            \"last_error\": self.last_error,\n            \"poll_interval\": self.config.poll_interval,\n            \"workers\": workers,\n        }\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.__init__","title":"<code>__init__(config_path='/data/config.json')</code>","text":"<p>Initialize executor.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str | Path</code> <p>Path to configuration file.</p> <code>'/data/config.json'</code> Source code in <code>executor/main.py</code> <pre><code>def __init__(self, config_path: str | Path = \"/data/config.json\"):\n    \"\"\"\n    Initialize executor.\n\n    Args:\n        config_path: Path to configuration file.\n    \"\"\"\n    self.config_path = Path(config_path)\n    self.config = Config.load(self.config_path)\n    self.transactions = TransactionStore(self.config.data_path)\n    self.adapter: BaseAdapter | None = None\n    self.running = False\n\n    # Track stats\n    self.tick_count = 0\n    self.last_tick_time: float | None = None\n    self.error_count = 0\n    self.last_error: str | None = None\n\n    # Tracked symbols and their EOD prices (from previous tick response)\n    self.symbols: list[str] = []\n    self.eod_prices: dict[str, float] = {}\n\n    # Strategy logs per worker\n    self.strategy_logs: dict[str, list] = {}\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.start","title":"<code>start()</code>","text":"<p>Start the executor.</p> <p>Validates config and connects to broker.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>None if started successfully, error message string otherwise.</p> Source code in <code>executor/main.py</code> <pre><code>def start(self) -&gt; str | None:\n    \"\"\"\n    Start the executor.\n\n    Validates config and connects to broker.\n\n    Returns:\n        None if started successfully, error message string otherwise.\n    \"\"\"\n    # Validate config\n    if not self.config.is_valid():\n        msg = \"Invalid config: API key is required\"\n        logger.error(msg)\n        return msg\n\n    # Create and connect adapter\n    adapter_name = self.config.adapter\n    try:\n        self.adapter = get_adapter(adapter_name, self.config.adapter_config)\n        if not self.adapter.connect():\n            msg = f\"{adapter_name}: failed to connect\"\n            logger.error(msg)\n            return msg\n    except Exception as e:\n        msg = f\"{adapter_name}: {e}\"\n        logger.error(msg)\n        return msg\n\n    logger.info(f\"Connected to {adapter_name} adapter\")\n    logger.info(f\"Poll interval: {self.config.poll_interval}s\")\n\n    self.running = True\n    return None\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.stop","title":"<code>stop()</code>","text":"<p>Stop the executor and disconnect from broker.</p> Source code in <code>executor/main.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop the executor and disconnect from broker.\"\"\"\n    self.running = False\n    if self.adapter:\n        self.adapter.disconnect()\n        logger.info(\"Disconnected from adapter\")\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.tick","title":"<code>tick()</code>","text":"<p>Execute one tick cycle.</p> <ol> <li>Get pending transactions</li> <li>Fetch quotes for tracked symbols</li> <li>Call TradeTracer /tick endpoint with prices + transactions</li> <li>Execute returned orders</li> <li>Store fills and symbols for next tick</li> </ol> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Result dict with tick details.</p> Source code in <code>executor/main.py</code> <pre><code>def tick(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Execute one tick cycle.\n\n    1. Get pending transactions\n    2. Fetch quotes for tracked symbols\n    3. Call TradeTracer /tick endpoint with prices + transactions\n    4. Execute returned orders\n    5. Store fills and symbols for next tick\n\n    Returns:\n        Result dict with tick details.\n    \"\"\"\n    assert self.adapter is not None\n\n    tick_start = time.time()\n    self.tick_count += 1\n    self.last_tick_time = time.time()\n\n    # 1. Get pending transactions to report\n    pending = self.transactions.get_pending()\n    logger.info(f\"Tick {self.tick_count}: {len(pending)} pending transactions\")\n\n    # 2. Fetch quotes for tracked symbols\n    prices: dict[str, Any] = {}\n    for symbol in self.symbols:\n        eod = self.eod_prices.get(symbol)\n        try:\n            quote = self.adapter.fetch_quote(symbol, eod)\n        except Exception as e:\n            logger.warning(f\"{self.config.adapter}: {symbol} fetch_quote failed: {e}\")\n            continue\n        if quote:\n            prices[symbol] = {\n                \"ohlcv\": {\n                    \"o\": quote.get(\"open\"),\n                    \"h\": quote.get(\"high\"),\n                    \"l\": quote.get(\"low\"),\n                    \"c\": quote.get(\"close\"),\n                    \"v\": quote.get(\"volume\"),\n                },\n                \"bid\": quote.get(\"bid\"),\n                \"ask\": quote.get(\"ask\"),\n                \"time\": int(time.time()),\n            }\n            logger.debug(f\"Quote {symbol}: {quote.get('close', 'N/A')}\")\n\n    # 3. Call TradeTracer /tick endpoint (hard 5s timeout)\n    def _post():\n        return requests.post(\n            self.config.get_tick_url(),\n            headers={\"Authorization\": f\"Bearer {self.config.api_key}\"},\n            json={\"prices\": prices, \"transactions\": pending},\n            timeout=5,\n        )\n\n    pool = ThreadPoolExecutor(max_workers=1)\n    future = pool.submit(_post)\n    try:\n        response = future.result(timeout=5)\n    except FuturesTimeout:\n        pool.shutdown(wait=False, cancel_futures=True)\n        error_msg = f\"Timeout: {self.config.get_tick_url()} did not respond in 5s\"\n        logger.error(error_msg)\n        self.error_count += 1\n        self.last_error = error_msg\n        return {\"success\": False, \"error\": error_msg}\n    except Exception as e:\n        pool.shutdown(wait=False, cancel_futures=True)\n        error_msg = f\"{type(e).__name__}: {e}\"\n        logger.error(f\"Tick failed: {error_msg}\")\n        self.error_count += 1\n        self.last_error = error_msg\n        return {\"success\": False, \"error\": error_msg}\n    else:\n        pool.shutdown(wait=False)\n\n    if not response.ok:\n        # Parse error detail from response body\n        detail = \"\"\n        try:\n            body = response.json()\n            if isinstance(body, dict):\n                detail = body.get(\"detail\") or body.get(\"error\") or \"\"\n            if isinstance(detail, dict):\n                detail = detail.get(\"error\", str(detail))\n        except Exception:\n            detail = response.text[:200]\n        error_msg = f\"{response.status_code}: {detail}\" if detail else f\"{response.status_code}\"\n        logger.error(f\"Tick failed: {error_msg}\")\n        self.error_count += 1\n        self.last_error = error_msg\n        return {\"success\": False, \"error\": error_msg}\n\n    # 4. Clear reported transactions\n    self.transactions.clear()\n\n    # 5. Process response\n    data = response.json()\n    orders = data.get(\"orders\", [])\n\n    # 6. Update tracked symbols and EOD prices from response\n    self.eod_prices = data.get(\"prices\", {})\n    self.symbols = list(self.eod_prices.keys())\n    logger.info(f\"Received {len(orders)} orders, tracking {len(self.symbols)} symbols\")\n\n    # 7. Capture strategy logs per worker\n    from datetime import datetime\n    ts = datetime.now().strftime(\"%I:%M:%S %p\")\n    logs = data.get(\"logs\", {})\n    for symbol, lines in logs.items():\n        if symbol not in self.strategy_logs:\n            self.strategy_logs[symbol] = []\n        for line in lines:\n            self.strategy_logs[symbol].append(f\"{ts} {line}\")\n        # Keep last 200\n        if len(self.strategy_logs[symbol]) &gt; 200:\n            self.strategy_logs[symbol] = self.strategy_logs[symbol][-200:]\n\n    # 8. Execute orders\n    new_transactions = []\n    for order in orders:\n        logger.info(\n            f\"Executing: {order['action'].upper()} \"\n            f\"{order['symbol']} x{order['volume']} @ {order['price']}\"\n        )\n\n        result = self.adapter.execute_order(order)\n\n        if result[\"success\"]:\n            tx = {\n                \"order_id\": order[\"order_id\"],\n                \"symbol\": order[\"symbol\"],\n                \"action\": order[\"action\"],\n                \"volume\": result[\"fill_shares\"],\n                \"price\": result[\"fill_price\"],\n                \"commission\": result[\"commission\"],\n                \"time\": int(time.time()),\n            }\n            new_transactions.append(tx)\n            logger.info(\n                f\"  Filled: {result['fill_shares']} @ ${result['fill_price']:.2f}\"\n            )\n        else:\n            logger.warning(f\"  {self.config.adapter}: {order['symbol']} {order['action']} failed: {result.get('error', 'Unknown error')}\")\n\n    # 9. Store new transactions for next tick\n    self.transactions.add(new_transactions)\n\n    tick_duration = time.time() - tick_start\n\n    return {\n        \"success\": True,\n        \"tick\": self.tick_count,\n        \"orders_received\": len(orders),\n        \"orders_filled\": len(new_transactions),\n        \"duration_ms\": int(tick_duration * 1000),\n    }\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.run","title":"<code>run()</code>","text":"<p>Run the executor loop.</p> <p>Blocks until stopped via signal or stop() call. Handles SIGINT and SIGTERM for graceful shutdown.</p> Source code in <code>executor/main.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the executor loop.\n\n    Blocks until stopped via signal or stop() call.\n    Handles SIGINT and SIGTERM for graceful shutdown.\n    \"\"\"\n\n    # Setup signal handlers\n    def handle_signal(signum: int, frame: Any) -&gt; None:\n        logger.info(\"Shutdown signal received\")\n        self.stop()\n\n    signal.signal(signal.SIGINT, handle_signal)\n    signal.signal(signal.SIGTERM, handle_signal)\n\n    # Start\n    error = self.start()\n    if error:\n        logger.error(f\"Failed to start executor: {error}\")\n        sys.exit(1)\n\n    logger.info(\"Executor started, entering main loop\")\n\n    # Main loop\n    while self.running:\n        try:\n            result = self.tick()\n            if result[\"success\"]:\n                logger.info(\n                    f\"Tick complete: {result['orders_filled']}/{result['orders_received']} \"\n                    f\"orders filled in {result['duration_ms']}ms\"\n                )\n        except Exception as e:\n            logger.error(f\"Tick error: {e}\")\n\n        # Wait for next tick\n        if self.running:\n            time.sleep(self.config.poll_interval)\n\n    logger.info(\"Executor stopped\")\n</code></pre>"},{"location":"reference/executor/#executor.main.Executor.get_status","title":"<code>get_status()</code>","text":"<p>Get executor status.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Status dict with running state, tick count, etc.</p> Source code in <code>executor/main.py</code> <pre><code>def get_status(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get executor status.\n\n    Returns:\n        Status dict with running state, tick count, etc.\n    \"\"\"\n    # Build worker info per symbol\n    workers = {}\n    for symbol in self.symbols:\n        workers[symbol] = {\n            \"price\": self.eod_prices.get(symbol),\n            \"logs\": list(self.strategy_logs.get(symbol, [])),\n        }\n\n    return {\n        \"running\": self.running,\n        \"tick_count\": self.tick_count,\n        \"last_tick_time\": self.last_tick_time,\n        \"pending_transactions\": self.transactions.count(),\n        \"config_valid\": self.config.is_valid(),\n        \"adapter\": self.config.adapter,\n        \"error_count\": self.error_count,\n        \"last_error\": self.last_error,\n        \"poll_interval\": self.config.poll_interval,\n        \"workers\": workers,\n    }\n</code></pre>"},{"location":"reference/executor/#executor.main.main","title":"<code>main()</code>","text":"<p>Entry point for command line usage.</p> Source code in <code>executor/main.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Entry point for command line usage.\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"TradeTracer Executor\")\n    parser.add_argument(\n        \"--config\",\n        default=\"/data/config.json\",\n        help=\"Path to config file\",\n    )\n    args = parser.parse_args()\n\n    executor = Executor(args.config)\n    executor.run()\n</code></pre>"},{"location":"reference/ibkr/","title":"Interactive Brokers","text":"<p>Connect to IBKR TWS or Gateway for live trading.</p> <p>Warning</p> <p>Requires <code>ib_insync</code> package: <code>pip install ib_insync</code></p>"},{"location":"reference/ibkr/#adapters.ibkr","title":"<code>ibkr</code>","text":"<p>Interactive Brokers adapter using ib_insync.</p> <p>Connects to TWS or IB Gateway for live/paper trading. Requires TWS/Gateway running with API connections enabled.</p> Example <pre><code>from adapters import get_adapter\n\nadapter = get_adapter(\"ibkr\", {\n    \"host\": \"127.0.0.1\",\n    \"port\": 7497,  # 7497 for paper, 7496 for live\n    \"client_id\": 1,\n})\nadapter.connect()\n\n# Fetch quote\nquote = adapter.fetch_quote(\"AAPL\", 185.0)\nprint(quote)  # {\"bid\": 186.45, \"ask\": 186.55, ...}\n\n# Execute order\nresult = adapter.execute_buy(\"AAPL\", 10, 186.50)\nprint(result)  # {\"success\": True, \"fill_price\": 186.52, ...}\n\nadapter.disconnect()\n</code></pre> Note <p>Install with: pip install ib_insync Or use the optional dependency: pip install tradetracer-executor[ibkr]</p>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter","title":"<code>IBKRAdapter</code>","text":"<p>               Bases: <code>BaseAdapter</code></p> <p>Interactive Brokers adapter.</p> <p>Connects to TWS or IB Gateway via the ib_insync library. Supports both live and paper trading accounts.</p> <p>Attributes:</p> Name Type Description <code>host</code> <p>TWS/Gateway hostname.</p> <code>port</code> <p>TWS/Gateway port (7497 paper, 7496 live).</p> <code>client_id</code> <p>Unique client identifier.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>class IBKRAdapter(BaseAdapter):\n    \"\"\"\n    Interactive Brokers adapter.\n\n    Connects to TWS or IB Gateway via the ib_insync library.\n    Supports both live and paper trading accounts.\n\n    Attributes:\n        host: TWS/Gateway hostname.\n        port: TWS/Gateway port (7497 paper, 7496 live).\n        client_id: Unique client identifier.\n    \"\"\"\n\n    def __init__(\n        self,\n        host: str = \"127.0.0.1\",\n        port: int = 7497,\n        client_id: int = 1,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize IBKR adapter.\n\n        Args:\n            host: TWS/Gateway hostname.\n            port: TWS/Gateway port. Use 7497 for paper trading,\n                  7496 for live trading.\n            client_id: Unique client ID. Each connection needs\n                       a different client_id.\n            **kwargs: Ignored (for compatibility with config loading).\n        \"\"\"\n        self.host = host\n        self.port = int(port)\n        self.client_id = int(client_id)\n        self._ib = None\n\n    @classmethod\n    def get_config_fields(cls) -&gt; list[ConfigField]:\n        \"\"\"\n        Return configuration fields for web UI.\n\n        Returns:\n            List with host, port, and client_id fields.\n        \"\"\"\n        return [\n            {\n                \"name\": \"host\",\n                \"label\": \"TWS/Gateway Host\",\n                \"type\": \"text\",\n                \"default\": \"127.0.0.1\",\n            },\n            {\n                \"name\": \"port\",\n                \"label\": \"Port\",\n                \"type\": \"number\",\n                \"default\": 7497,\n                \"help\": \"7497 for paper trading, 7496 for live\",\n            },\n            {\n                \"name\": \"client_id\",\n                \"label\": \"Client ID\",\n                \"type\": \"number\",\n                \"default\": 1,\n            },\n        ]\n\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to TWS/Gateway.\n\n        Returns:\n            True if connection successful, False otherwise.\n        \"\"\"\n        try:\n            from ib_insync import IB\n\n            self._ib = IB()\n            self._ib.connect(\n                host=self.host,\n                port=self.port,\n                clientId=self.client_id,\n                readonly=False,\n            )\n            return self._ib.isConnected()\n        except ImportError:\n            print(\"[ERROR] ib_insync not installed. Run: pip install ib_insync\")\n            return False\n        except Exception as e:\n            print(f\"[ERROR] IBKR connection failed: {e}\")\n            return False\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from TWS/Gateway.\"\"\"\n        if self._ib and self._ib.isConnected():\n            self._ib.disconnect()\n        self._ib = None\n\n    def _get_contract(self, symbol: str):\n        \"\"\"Create a Stock contract for a symbol.\"\"\"\n        from ib_insync import Stock\n\n        return Stock(symbol, \"SMART\", \"USD\")\n\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a market buy order.\n\n        Args:\n            symbol: Stock symbol (e.g., \"AAPL\").\n            shares: Number of shares to buy.\n            price: Reference price (not used for market orders).\n\n        Returns:\n            Fill details or error dict.\n        \"\"\"\n        return self._execute_order(symbol, \"BUY\", shares)\n\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a market sell order.\n\n        Args:\n            symbol: Stock symbol (e.g., \"AAPL\").\n            shares: Number of shares to sell.\n            price: Reference price (not used for market orders).\n\n        Returns:\n            Fill details or error dict.\n        \"\"\"\n        return self._execute_order(symbol, \"SELL\", shares)\n\n    def _execute_order(self, symbol: str, action: str, shares: int) -&gt; FillResult:\n        \"\"\"\n        Execute a market order.\n\n        Args:\n            symbol: Stock symbol.\n            action: \"BUY\" or \"SELL\".\n            shares: Number of shares.\n\n        Returns:\n            Fill details or error dict.\n        \"\"\"\n        if not self._ib or not self._ib.isConnected():\n            return {\"success\": False, \"error\": \"Not connected\"}\n\n        try:\n            from ib_insync import MarketOrder\n\n            contract = self._get_contract(symbol)\n            order = MarketOrder(action, shares)\n\n            trade = self._ib.placeOrder(contract, order)\n\n            # Wait for fill (up to 30 seconds)\n            timeout = 30\n            while not trade.isDone() and timeout &gt; 0:\n                self._ib.sleep(1)\n                timeout -= 1\n\n            if trade.orderStatus.status == \"Filled\":\n                return {\n                    \"success\": True,\n                    \"fill_price\": trade.orderStatus.avgFillPrice,\n                    \"fill_shares\": int(trade.orderStatus.filled),\n                    \"commission\": self._get_commission(trade),\n                }\n            else:\n                return {\n                    \"success\": False,\n                    \"error\": f\"Order not filled: {trade.orderStatus.status}\",\n                }\n\n        except Exception as e:\n            return {\"success\": False, \"error\": str(e)}\n\n    def _get_commission(self, trade) -&gt; float:\n        \"\"\"Extract commission from trade fills.\"\"\"\n        total = 0.0\n        for fill in trade.fills:\n            if fill.commissionReport:\n                total += fill.commissionReport.commission or 0.0\n        return total\n\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        \"\"\"\n        Fetch a real-time quote from TWS/Gateway.\n\n        Args:\n            symbol: Stock symbol (e.g., \"AAPL\").\n            eod_last_price: EOD close from TradeTracer (unused, real data\n                is fetched from the broker).\n\n        Returns:\n            Quote dict with OHLCV and bid/ask, or None if unavailable.\n        \"\"\"\n        if not self._ib or not self._ib.isConnected():\n            return None\n\n        try:\n            contract = self._get_contract(symbol)\n\n            # Request market data snapshot\n            self._ib.qualifyContracts(contract)\n            ticker = self._ib.reqMktData(contract, snapshot=True)\n\n            # Wait for data (up to 5 seconds)\n            timeout = 5\n            while ticker.last != ticker.last and timeout &gt; 0:  # NaN check\n                self._ib.sleep(0.5)\n                timeout -= 0.5\n\n            # Check if we have valid data\n            if not _is_valid(ticker.last) and not _is_valid(ticker.bid):\n                return None\n\n            return {\n                \"open\": _safe_float(ticker.open),\n                \"high\": _safe_float(ticker.high),\n                \"low\": _safe_float(ticker.low),\n                \"close\": _safe_float(ticker.last),\n                \"volume\": _safe_int(ticker.volume),\n                \"bid\": _safe_float(ticker.bid),\n                \"ask\": _safe_float(ticker.ask),\n            }\n\n        except Exception as e:\n            print(f\"[WARN] Failed to get quote for {symbol}: {e}\")\n            return None\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.__init__","title":"<code>__init__(host='127.0.0.1', port=7497, client_id=1, **kwargs)</code>","text":"<p>Initialize IBKR adapter.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>TWS/Gateway hostname.</p> <code>'127.0.0.1'</code> <code>port</code> <code>int</code> <p>TWS/Gateway port. Use 7497 for paper trading,   7496 for live trading.</p> <code>7497</code> <code>client_id</code> <code>int</code> <p>Unique client ID. Each connection needs        a different client_id.</p> <code>1</code> <code>**kwargs</code> <p>Ignored (for compatibility with config loading).</p> <code>{}</code> Source code in <code>adapters/ibkr.py</code> <pre><code>def __init__(\n    self,\n    host: str = \"127.0.0.1\",\n    port: int = 7497,\n    client_id: int = 1,\n    **kwargs,\n):\n    \"\"\"\n    Initialize IBKR adapter.\n\n    Args:\n        host: TWS/Gateway hostname.\n        port: TWS/Gateway port. Use 7497 for paper trading,\n              7496 for live trading.\n        client_id: Unique client ID. Each connection needs\n                   a different client_id.\n        **kwargs: Ignored (for compatibility with config loading).\n    \"\"\"\n    self.host = host\n    self.port = int(port)\n    self.client_id = int(client_id)\n    self._ib = None\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.get_config_fields","title":"<code>get_config_fields()</code>  <code>classmethod</code>","text":"<p>Return configuration fields for web UI.</p> <p>Returns:</p> Type Description <code>list[ConfigField]</code> <p>List with host, port, and client_id fields.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>@classmethod\ndef get_config_fields(cls) -&gt; list[ConfigField]:\n    \"\"\"\n    Return configuration fields for web UI.\n\n    Returns:\n        List with host, port, and client_id fields.\n    \"\"\"\n    return [\n        {\n            \"name\": \"host\",\n            \"label\": \"TWS/Gateway Host\",\n            \"type\": \"text\",\n            \"default\": \"127.0.0.1\",\n        },\n        {\n            \"name\": \"port\",\n            \"label\": \"Port\",\n            \"type\": \"number\",\n            \"default\": 7497,\n            \"help\": \"7497 for paper trading, 7496 for live\",\n        },\n        {\n            \"name\": \"client_id\",\n            \"label\": \"Client ID\",\n            \"type\": \"number\",\n            \"default\": 1,\n        },\n    ]\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.connect","title":"<code>connect()</code>","text":"<p>Connect to TWS/Gateway.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection successful, False otherwise.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>def connect(self) -&gt; bool:\n    \"\"\"\n    Connect to TWS/Gateway.\n\n    Returns:\n        True if connection successful, False otherwise.\n    \"\"\"\n    try:\n        from ib_insync import IB\n\n        self._ib = IB()\n        self._ib.connect(\n            host=self.host,\n            port=self.port,\n            clientId=self.client_id,\n            readonly=False,\n        )\n        return self._ib.isConnected()\n    except ImportError:\n        print(\"[ERROR] ib_insync not installed. Run: pip install ib_insync\")\n        return False\n    except Exception as e:\n        print(f\"[ERROR] IBKR connection failed: {e}\")\n        return False\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from TWS/Gateway.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from TWS/Gateway.\"\"\"\n    if self._ib and self._ib.isConnected():\n        self._ib.disconnect()\n    self._ib = None\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.execute_buy","title":"<code>execute_buy(symbol, shares, price)</code>","text":"<p>Execute a market buy order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol (e.g., \"AAPL\").</p> required <code>shares</code> <code>int</code> <p>Number of shares to buy.</p> required <code>price</code> <code>float</code> <p>Reference price (not used for market orders).</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill details or error dict.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a market buy order.\n\n    Args:\n        symbol: Stock symbol (e.g., \"AAPL\").\n        shares: Number of shares to buy.\n        price: Reference price (not used for market orders).\n\n    Returns:\n        Fill details or error dict.\n    \"\"\"\n    return self._execute_order(symbol, \"BUY\", shares)\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.execute_sell","title":"<code>execute_sell(symbol, shares, price)</code>","text":"<p>Execute a market sell order.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol (e.g., \"AAPL\").</p> required <code>shares</code> <code>int</code> <p>Number of shares to sell.</p> required <code>price</code> <code>float</code> <p>Reference price (not used for market orders).</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill details or error dict.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a market sell order.\n\n    Args:\n        symbol: Stock symbol (e.g., \"AAPL\").\n        shares: Number of shares to sell.\n        price: Reference price (not used for market orders).\n\n    Returns:\n        Fill details or error dict.\n    \"\"\"\n    return self._execute_order(symbol, \"SELL\", shares)\n</code></pre>"},{"location":"reference/ibkr/#adapters.ibkr.IBKRAdapter.fetch_quote","title":"<code>fetch_quote(symbol, eod_last_price)</code>","text":"<p>Fetch a real-time quote from TWS/Gateway.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol (e.g., \"AAPL\").</p> required <code>eod_last_price</code> <code>float | None</code> <p>EOD close from TradeTracer (unused, real data is fetched from the broker).</p> required <p>Returns:</p> Type Description <code>Quote | None</code> <p>Quote dict with OHLCV and bid/ask, or None if unavailable.</p> Source code in <code>adapters/ibkr.py</code> <pre><code>def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n    \"\"\"\n    Fetch a real-time quote from TWS/Gateway.\n\n    Args:\n        symbol: Stock symbol (e.g., \"AAPL\").\n        eod_last_price: EOD close from TradeTracer (unused, real data\n            is fetched from the broker).\n\n    Returns:\n        Quote dict with OHLCV and bid/ask, or None if unavailable.\n    \"\"\"\n    if not self._ib or not self._ib.isConnected():\n        return None\n\n    try:\n        contract = self._get_contract(symbol)\n\n        # Request market data snapshot\n        self._ib.qualifyContracts(contract)\n        ticker = self._ib.reqMktData(contract, snapshot=True)\n\n        # Wait for data (up to 5 seconds)\n        timeout = 5\n        while ticker.last != ticker.last and timeout &gt; 0:  # NaN check\n            self._ib.sleep(0.5)\n            timeout -= 0.5\n\n        # Check if we have valid data\n        if not _is_valid(ticker.last) and not _is_valid(ticker.bid):\n            return None\n\n        return {\n            \"open\": _safe_float(ticker.open),\n            \"high\": _safe_float(ticker.high),\n            \"low\": _safe_float(ticker.low),\n            \"close\": _safe_float(ticker.last),\n            \"volume\": _safe_int(ticker.volume),\n            \"bid\": _safe_float(ticker.bid),\n            \"ask\": _safe_float(ticker.ask),\n        }\n\n    except Exception as e:\n        print(f\"[WARN] Failed to get quote for {symbol}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/sandbox/","title":"Sandbox Adapter","text":"<p>Paper trading adapter for testing without real money.</p>"},{"location":"reference/sandbox/#adapters.sandbox","title":"<code>sandbox</code>","text":"<p>Sandbox adapter for paper trading.</p> <p>Simulates order execution without a real broker. Every order fills immediately at the given price with zero commission. Intraday prices are simulated via a random walk from the EOD close.</p> Example <pre><code>from adapters import get_adapter\n\nadapter = get_adapter(\"sandbox\", {})\nadapter.connect()\n\nquote = adapter.fetch_quote(\"AAPL\", 186.50)\n# {\"close\": 186.32, \"bid\": 186.31, \"ask\": 186.33}\n\nresult = adapter.execute_buy(\"AAPL\", 10, 186.33)\n# {\"success\": True, \"fill_price\": 186.33, \"fill_shares\": 10, \"commission\": 0}\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter","title":"<code>SandboxAdapter</code>","text":"<p>               Bases: <code>BaseAdapter</code></p> <p>Paper trading adapter.</p> <p>Every order fills immediately at the requested price. Intraday prices are simulated as a random walk from the EOD close.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>class SandboxAdapter(BaseAdapter):\n    \"\"\"\n    Paper trading adapter.\n\n    Every order fills immediately at the requested price.\n    Intraday prices are simulated as a random walk from the EOD close.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self._last_prices: dict[str, float] = {}\n        self._session: dict[str, dict] = {}  # {symbol: {open, high, low}}\n\n    @classmethod\n    def get_config_fields(cls) -&gt; list[ConfigField]:\n        \"\"\"\n        Return configuration fields for web UI.\n\n        Returns:\n            Empty list \u2014 sandbox needs no configuration.\n        \"\"\"\n        return []\n\n    def connect(self) -&gt; bool:\n        \"\"\"\n        Connect to sandbox.\n\n        Returns:\n            Always True.\n        \"\"\"\n        return True\n\n    def disconnect(self) -&gt; None:\n        \"\"\"Disconnect from sandbox.\"\"\"\n        self._last_prices.clear()\n        self._session.clear()\n\n    def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a buy order.\n\n        Fills immediately at the given price with zero commission.\n\n        Args:\n            symbol: Stock symbol.\n            shares: Number of shares to buy.\n            price: Price per share.\n\n        Returns:\n            Fill result with the requested price and shares.\n        \"\"\"\n        return {\n            \"success\": True,\n            \"fill_price\": price,\n            \"fill_shares\": shares,\n            \"commission\": 0.0,\n        }\n\n    def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n        \"\"\"\n        Execute a sell order.\n\n        Fills immediately at the given price with zero commission.\n\n        Args:\n            symbol: Stock symbol.\n            shares: Number of shares to sell.\n            price: Price per share.\n\n        Returns:\n            Fill result with the requested price and shares.\n        \"\"\"\n        return {\n            \"success\": True,\n            \"fill_price\": price,\n            \"fill_shares\": shares,\n            \"commission\": 0.0,\n        }\n\n    def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n        \"\"\"\n        Simulate an intraday quote via random walk.\n\n        On the first call for a symbol, starts from the EOD close price.\n        On subsequent calls, walks from the previous simulated price.\n        Uses a random walk to simulate realistic intraday movement.\n\n        Args:\n            symbol: Stock symbol.\n            eod_last_price: Last EOD close from TradeTracer.\n\n        Returns:\n            Simulated quote, or None if no EOD price available.\n        \"\"\"\n        if not eod_last_price:\n            return None\n\n        base = self._last_prices.get(symbol, eod_last_price)\n        step = random.uniform(-0.005, 0.005)\n        price = round(base * (1 + step), 2)\n        self._last_prices[symbol] = price\n\n        # Track intraday session (open/high/low)\n        if symbol not in self._session:\n            self._session[symbol] = {\"open\": price, \"high\": price, \"low\": price}\n        sess = self._session[symbol]\n        sess[\"high\"] = max(sess[\"high\"], price)\n        sess[\"low\"] = min(sess[\"low\"], price)\n\n        # Spread: 0.01-0.05% of price, varies per tick\n        spread_pct = random.uniform(0.0001, 0.0005)\n        half_spread = round(price * spread_pct, 2) or 0.01\n\n        # Bid/ask: last trade (close) is between bid and ask\n        bid = round(price - half_spread, 2)\n        ask = round(price + half_spread, 2)\n\n        return {\n            \"open\": sess[\"open\"],\n            \"high\": sess[\"high\"],\n            \"low\": sess[\"low\"],\n            \"close\": price,\n            \"volume\": random.randint(100, 5000),\n            \"bid\": bid,\n            \"ask\": ask,\n        }\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.get_config_fields","title":"<code>get_config_fields()</code>  <code>classmethod</code>","text":"<p>Return configuration fields for web UI.</p> <p>Returns:</p> Type Description <code>list[ConfigField]</code> <p>Empty list \u2014 sandbox needs no configuration.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>@classmethod\ndef get_config_fields(cls) -&gt; list[ConfigField]:\n    \"\"\"\n    Return configuration fields for web UI.\n\n    Returns:\n        Empty list \u2014 sandbox needs no configuration.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.connect","title":"<code>connect()</code>","text":"<p>Connect to sandbox.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Always True.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def connect(self) -&gt; bool:\n    \"\"\"\n    Connect to sandbox.\n\n    Returns:\n        Always True.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnect from sandbox.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def disconnect(self) -&gt; None:\n    \"\"\"Disconnect from sandbox.\"\"\"\n    self._last_prices.clear()\n    self._session.clear()\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.execute_buy","title":"<code>execute_buy(symbol, shares, price)</code>","text":"<p>Execute a buy order.</p> <p>Fills immediately at the given price with zero commission.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>shares</code> <code>int</code> <p>Number of shares to buy.</p> required <code>price</code> <code>float</code> <p>Price per share.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill result with the requested price and shares.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def execute_buy(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a buy order.\n\n    Fills immediately at the given price with zero commission.\n\n    Args:\n        symbol: Stock symbol.\n        shares: Number of shares to buy.\n        price: Price per share.\n\n    Returns:\n        Fill result with the requested price and shares.\n    \"\"\"\n    return {\n        \"success\": True,\n        \"fill_price\": price,\n        \"fill_shares\": shares,\n        \"commission\": 0.0,\n    }\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.execute_sell","title":"<code>execute_sell(symbol, shares, price)</code>","text":"<p>Execute a sell order.</p> <p>Fills immediately at the given price with zero commission.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>shares</code> <code>int</code> <p>Number of shares to sell.</p> required <code>price</code> <code>float</code> <p>Price per share.</p> required <p>Returns:</p> Type Description <code>FillResult</code> <p>Fill result with the requested price and shares.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def execute_sell(self, symbol: str, shares: int, price: float) -&gt; FillResult:\n    \"\"\"\n    Execute a sell order.\n\n    Fills immediately at the given price with zero commission.\n\n    Args:\n        symbol: Stock symbol.\n        shares: Number of shares to sell.\n        price: Price per share.\n\n    Returns:\n        Fill result with the requested price and shares.\n    \"\"\"\n    return {\n        \"success\": True,\n        \"fill_price\": price,\n        \"fill_shares\": shares,\n        \"commission\": 0.0,\n    }\n</code></pre>"},{"location":"reference/sandbox/#adapters.sandbox.SandboxAdapter.fetch_quote","title":"<code>fetch_quote(symbol, eod_last_price)</code>","text":"<p>Simulate an intraday quote via random walk.</p> <p>On the first call for a symbol, starts from the EOD close price. On subsequent calls, walks from the previous simulated price. Uses a random walk to simulate realistic intraday movement.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock symbol.</p> required <code>eod_last_price</code> <code>float | None</code> <p>Last EOD close from TradeTracer.</p> required <p>Returns:</p> Type Description <code>Quote | None</code> <p>Simulated quote, or None if no EOD price available.</p> Source code in <code>adapters/sandbox.py</code> <pre><code>def fetch_quote(self, symbol: str, eod_last_price: float | None) -&gt; Quote | None:\n    \"\"\"\n    Simulate an intraday quote via random walk.\n\n    On the first call for a symbol, starts from the EOD close price.\n    On subsequent calls, walks from the previous simulated price.\n    Uses a random walk to simulate realistic intraday movement.\n\n    Args:\n        symbol: Stock symbol.\n        eod_last_price: Last EOD close from TradeTracer.\n\n    Returns:\n        Simulated quote, or None if no EOD price available.\n    \"\"\"\n    if not eod_last_price:\n        return None\n\n    base = self._last_prices.get(symbol, eod_last_price)\n    step = random.uniform(-0.005, 0.005)\n    price = round(base * (1 + step), 2)\n    self._last_prices[symbol] = price\n\n    # Track intraday session (open/high/low)\n    if symbol not in self._session:\n        self._session[symbol] = {\"open\": price, \"high\": price, \"low\": price}\n    sess = self._session[symbol]\n    sess[\"high\"] = max(sess[\"high\"], price)\n    sess[\"low\"] = min(sess[\"low\"], price)\n\n    # Spread: 0.01-0.05% of price, varies per tick\n    spread_pct = random.uniform(0.0001, 0.0005)\n    half_spread = round(price * spread_pct, 2) or 0.01\n\n    # Bid/ask: last trade (close) is between bid and ask\n    bid = round(price - half_spread, 2)\n    ask = round(price + half_spread, 2)\n\n    return {\n        \"open\": sess[\"open\"],\n        \"high\": sess[\"high\"],\n        \"low\": sess[\"low\"],\n        \"close\": price,\n        \"volume\": random.randint(100, 5000),\n        \"bid\": bid,\n        \"ask\": ask,\n    }\n</code></pre>"},{"location":"reference/transactions/","title":"Transactions","text":"<p>Pending transaction storage between ticks.</p>"},{"location":"reference/transactions/#executor.transactions","title":"<code>transactions</code>","text":"<p>Pending transaction storage for TradeTracer Executor.</p> <p>Transactions (order fills) are stored locally until they're successfully reported to TradeTracer on the next tick.</p> <p>This provides resilience against network failures - if a tick fails, the transactions aren't lost and will be reported on the next attempt.</p> Example <pre><code>from executor.transactions import TransactionStore\n\nstore = TransactionStore(\"/data\")\n\n# Add transactions after executing orders\nstore.add([\n    {\n        \"order_id\": \"abc-123\",\n        \"symbol\": \"AAPL\",\n        \"action\": \"buy\",\n        \"volume\": 10,\n        \"price\": 186.50,\n        \"commission\": 1.00,\n        \"time\": 1707500000,\n    }\n])\n\n# Get pending transactions to report\npending = store.get_pending()\n\n# Clear after successful report\nstore.clear()\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore","title":"<code>TransactionStore</code>","text":"<p>Stores pending transactions in a JSON file.</p> <p>Transactions are order fills that need to be reported to TradeTracer. They're stored locally to survive restarts and network failures.</p> <p>Attributes:</p> Name Type Description <code>file_path</code> <p>Path to the pending transactions JSON file.</p> Source code in <code>executor/transactions.py</code> <pre><code>class TransactionStore:\n    \"\"\"\n    Stores pending transactions in a JSON file.\n\n    Transactions are order fills that need to be reported to TradeTracer.\n    They're stored locally to survive restarts and network failures.\n\n    Attributes:\n        file_path: Path to the pending transactions JSON file.\n    \"\"\"\n\n    def __init__(self, data_path: str | Path):\n        \"\"\"\n        Initialize transaction store.\n\n        Args:\n            data_path: Path to data directory.\n        \"\"\"\n        self.file_path = Path(data_path) / \"pending_tx.json\"\n        self._ensure_file()\n\n    def _ensure_file(self) -&gt; None:\n        \"\"\"Create file with empty array if it doesn't exist.\"\"\"\n        self.file_path.parent.mkdir(parents=True, exist_ok=True)\n        if not self.file_path.exists():\n            self.file_path.write_text(\"[]\")\n\n    def get_pending(self) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Get all pending transactions.\n\n        Returns:\n            List of transaction dicts to report to TradeTracer.\n\n        Example:\n            ```python\n            pending = store.get_pending()\n            # [{\"order_id\": \"abc\", \"symbol\": \"AAPL\", ...}]\n            ```\n        \"\"\"\n        try:\n            return json.loads(self.file_path.read_text())\n        except (json.JSONDecodeError, FileNotFoundError):\n            return []\n\n    def add(self, transactions: list[dict[str, Any]]) -&gt; None:\n        \"\"\"\n        Add transactions to pending list.\n\n        Args:\n            transactions: List of transaction dicts with keys:\n                - order_id: ID of the original order\n                - symbol: Stock symbol\n                - action: \"buy\" or \"sell\"\n                - volume: Number of shares filled\n                - price: Fill price\n                - commission: Broker commission\n                - time: Unix timestamp of fill\n\n        Example:\n            ```python\n            store.add([{\n                \"order_id\": \"abc-123\",\n                \"symbol\": \"AAPL\",\n                \"action\": \"buy\",\n                \"volume\": 10,\n                \"price\": 186.50,\n                \"commission\": 1.00,\n                \"time\": 1707500000,\n            }])\n            ```\n        \"\"\"\n        if not transactions:\n            return\n\n        current = self.get_pending()\n        current.extend(transactions)\n        self.file_path.write_text(json.dumps(current, indent=2))\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Clear all pending transactions.\n\n        Call this after successfully reporting transactions to TradeTracer.\n\n        Example:\n            ```python\n            pending = store.get_pending()\n            if report_to_tradetracer(pending):\n                store.clear()\n            ```\n        \"\"\"\n        self.file_path.write_text(\"[]\")\n\n    def count(self) -&gt; int:\n        \"\"\"\n        Get number of pending transactions.\n\n        Returns:\n            Count of pending transactions.\n        \"\"\"\n        return len(self.get_pending())\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore.__init__","title":"<code>__init__(data_path)</code>","text":"<p>Initialize transaction store.</p> <p>Parameters:</p> Name Type Description Default <code>data_path</code> <code>str | Path</code> <p>Path to data directory.</p> required Source code in <code>executor/transactions.py</code> <pre><code>def __init__(self, data_path: str | Path):\n    \"\"\"\n    Initialize transaction store.\n\n    Args:\n        data_path: Path to data directory.\n    \"\"\"\n    self.file_path = Path(data_path) / \"pending_tx.json\"\n    self._ensure_file()\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore.get_pending","title":"<code>get_pending()</code>","text":"<p>Get all pending transactions.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of transaction dicts to report to TradeTracer.</p> Example <pre><code>pending = store.get_pending()\n# [{\"order_id\": \"abc\", \"symbol\": \"AAPL\", ...}]\n</code></pre> Source code in <code>executor/transactions.py</code> <pre><code>def get_pending(self) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Get all pending transactions.\n\n    Returns:\n        List of transaction dicts to report to TradeTracer.\n\n    Example:\n        ```python\n        pending = store.get_pending()\n        # [{\"order_id\": \"abc\", \"symbol\": \"AAPL\", ...}]\n        ```\n    \"\"\"\n    try:\n        return json.loads(self.file_path.read_text())\n    except (json.JSONDecodeError, FileNotFoundError):\n        return []\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore.add","title":"<code>add(transactions)</code>","text":"<p>Add transactions to pending list.</p> <p>Parameters:</p> Name Type Description Default <code>transactions</code> <code>list[dict[str, Any]]</code> <p>List of transaction dicts with keys: - order_id: ID of the original order - symbol: Stock symbol - action: \"buy\" or \"sell\" - volume: Number of shares filled - price: Fill price - commission: Broker commission - time: Unix timestamp of fill</p> required Example <pre><code>store.add([{\n    \"order_id\": \"abc-123\",\n    \"symbol\": \"AAPL\",\n    \"action\": \"buy\",\n    \"volume\": 10,\n    \"price\": 186.50,\n    \"commission\": 1.00,\n    \"time\": 1707500000,\n}])\n</code></pre> Source code in <code>executor/transactions.py</code> <pre><code>def add(self, transactions: list[dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Add transactions to pending list.\n\n    Args:\n        transactions: List of transaction dicts with keys:\n            - order_id: ID of the original order\n            - symbol: Stock symbol\n            - action: \"buy\" or \"sell\"\n            - volume: Number of shares filled\n            - price: Fill price\n            - commission: Broker commission\n            - time: Unix timestamp of fill\n\n    Example:\n        ```python\n        store.add([{\n            \"order_id\": \"abc-123\",\n            \"symbol\": \"AAPL\",\n            \"action\": \"buy\",\n            \"volume\": 10,\n            \"price\": 186.50,\n            \"commission\": 1.00,\n            \"time\": 1707500000,\n        }])\n        ```\n    \"\"\"\n    if not transactions:\n        return\n\n    current = self.get_pending()\n    current.extend(transactions)\n    self.file_path.write_text(json.dumps(current, indent=2))\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore.clear","title":"<code>clear()</code>","text":"<p>Clear all pending transactions.</p> <p>Call this after successfully reporting transactions to TradeTracer.</p> Example <pre><code>pending = store.get_pending()\nif report_to_tradetracer(pending):\n    store.clear()\n</code></pre> Source code in <code>executor/transactions.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clear all pending transactions.\n\n    Call this after successfully reporting transactions to TradeTracer.\n\n    Example:\n        ```python\n        pending = store.get_pending()\n        if report_to_tradetracer(pending):\n            store.clear()\n        ```\n    \"\"\"\n    self.file_path.write_text(\"[]\")\n</code></pre>"},{"location":"reference/transactions/#executor.transactions.TransactionStore.count","title":"<code>count()</code>","text":"<p>Get number of pending transactions.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of pending transactions.</p> Source code in <code>executor/transactions.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"\n    Get number of pending transactions.\n\n    Returns:\n        Count of pending transactions.\n    \"\"\"\n    return len(self.get_pending())\n</code></pre>"},{"location":"reference/web/","title":"Web UI","text":"<p>Flask-based configuration and control interface.</p>"},{"location":"reference/web/#web.app","title":"<code>app</code>","text":"<p>Flask web application for TradeTracer Executor.</p> <p>Provides a configuration UI and executor control endpoints.</p> Example <pre><code>from web import create_app\n\napp = create_app()\napp.run(host=\"0.0.0.0\", port=5000)\n</code></pre>"},{"location":"reference/web/#web.app.create_app","title":"<code>create_app(config_path='/data/config.json')</code>","text":"<p>Create Flask application.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>str</code> <p>Path to configuration file.</p> <code>'/data/config.json'</code> <p>Returns:</p> Type Description <code>Flask</code> <p>Configured Flask app.</p> Source code in <code>web/app.py</code> <pre><code>def create_app(config_path: str = \"/data/config.json\") -&gt; Flask:\n    \"\"\"\n    Create Flask application.\n\n    Args:\n        config_path: Path to configuration file.\n\n    Returns:\n        Configured Flask app.\n    \"\"\"\n    app = Flask(__name__)\n    app.config[\"CONFIG_PATH\"] = config_path\n\n    # Ensure data directory exists\n    Path(config_path).parent.mkdir(parents=True, exist_ok=True)\n\n    register_routes(app)\n    return app\n</code></pre>"},{"location":"reference/web/#web.app.register_routes","title":"<code>register_routes(app)</code>","text":"<p>Register all routes on the app.</p> Source code in <code>web/app.py</code> <pre><code>def register_routes(app: Flask) -&gt; None:\n    \"\"\"Register all routes on the app.\"\"\"\n\n    @app.route(\"/\")\n    def index() -&gt; str:\n        \"\"\"Render main UI.\"\"\"\n        config = Config.load(app.config[\"CONFIG_PATH\"])\n        adapters = list_adapters()\n\n        return render_template(\n            \"index.html\",\n            config=config,\n            adapters=adapters,\n            adapter_fields=get_adapter_fields(config.adapter),\n        )\n\n    @app.route(\"/api/config\", methods=[\"GET\"])\n    def get_config() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Get current configuration.\"\"\"\n        config = Config.load(app.config[\"CONFIG_PATH\"])\n        return jsonify(\n            {\n                \"api_key\": \"***\" if config.api_key else \"\",  # Mask API key\n                \"adapter\": config.adapter,\n                \"adapter_config\": config.adapter_config,\n                \"api_url\": config.api_url,\n                \"poll_interval\": config.poll_interval,\n            }\n        ), 200\n\n    @app.route(\"/api/config\", methods=[\"POST\"])\n    def save_config() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Save configuration.\"\"\"\n        data = request.json or {}\n\n        config = Config.load(app.config[\"CONFIG_PATH\"])\n\n        # Update fields if provided\n        if \"api_key\" in data and data[\"api_key\"] != \"***\":\n            config.api_key = data[\"api_key\"]\n        if \"adapter\" in data:\n            config.adapter = data[\"adapter\"]\n        if \"adapter_config\" in data:\n            config.adapter_config = data[\"adapter_config\"]\n        if \"api_url\" in data:\n            config.api_url = data[\"api_url\"]\n        if \"poll_interval\" in data:\n            config.poll_interval = int(data[\"poll_interval\"])\n\n        config.save(app.config[\"CONFIG_PATH\"])\n\n        return jsonify({\"success\": True}), 200\n\n    @app.route(\"/api/adapters\", methods=[\"GET\"])\n    def get_adapters() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Get available adapters and their fields.\"\"\"\n        adapters = {}\n        for adapter_type in list_adapters():\n            adapters[adapter_type] = get_adapter_fields(adapter_type)\n        return jsonify(adapters), 200\n\n    @app.route(\"/api/status\", methods=[\"GET\"])\n    def get_status() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Get executor status.\"\"\"\n        global _executor\n\n        if _executor:\n            status = _executor.get_status()\n        else:\n            config = Config.load(app.config[\"CONFIG_PATH\"])\n            status = {\n                \"running\": False,\n                \"tick_count\": 0,\n                \"last_tick_time\": None,\n                \"pending_transactions\": 0,\n                \"config_valid\": config.is_valid(),\n                \"adapter\": config.adapter,\n                \"error_count\": 0,\n                \"last_error\": None,\n                \"poll_interval\": config.poll_interval,\n                \"workers\": {},\n            }\n\n        return jsonify(status), 200\n\n    @app.route(\"/api/start\", methods=[\"POST\"])\n    def start_executor() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Start the executor.\"\"\"\n        global _executor, _executor_thread\n\n        with _executor_lock:\n            if _executor and _executor.running:\n                return jsonify({\"error\": \"Already running\"}), 400\n\n            _executor = Executor(app.config[\"CONFIG_PATH\"])\n\n            error = _executor.start()\n            if error:\n                _executor = None\n                return jsonify({\"error\": error}), 500\n\n            # Run in background thread\n            def run_loop():\n                ex = _executor\n                if not ex:\n                    return\n                while ex.running:\n                    try:\n                        ex.tick()\n                    except Exception:\n                        pass\n                    if ex.running:\n                        import time\n\n                        time.sleep(ex.config.poll_interval)\n\n            _executor_thread = threading.Thread(target=run_loop, daemon=True)\n            _executor_thread.start()\n\n        return jsonify({\"success\": True}), 200\n\n    @app.route(\"/api/stop\", methods=[\"POST\"])\n    def stop_executor() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Stop the executor.\"\"\"\n        global _executor, _executor_thread\n\n        with _executor_lock:\n            if not _executor or not _executor.running:\n                return jsonify({\"error\": \"Not running\"}), 400\n\n            _executor.stop()\n            _executor_thread = None\n\n        return jsonify({\"success\": True}), 200\n\n    @app.route(\"/api/workers/&lt;symbol&gt;/logs\", methods=[\"DELETE\"])\n    def clear_worker_logs(symbol: str) -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Clear logs for a specific worker.\"\"\"\n        global _executor\n        if _executor and symbol in _executor.strategy_logs:\n            _executor.strategy_logs[symbol].clear()\n        return jsonify({\"success\": True}), 200\n\n    @app.route(\"/api/tick\", methods=[\"POST\"])\n    def manual_tick() -&gt; tuple[dict[str, Any], int]:\n        \"\"\"Trigger a manual tick (for testing).\"\"\"\n        global _executor\n\n        with _executor_lock:\n            if not _executor or not _executor.running:\n                return jsonify({\"error\": \"Not running\"}), 400\n\n            result = _executor.tick()\n\n        return jsonify(result), 200\n</code></pre>"},{"location":"reference/web/#web.app.main","title":"<code>main()</code>","text":"<p>Run the web server.</p> Source code in <code>web/app.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Run the web server.\"\"\"\n    import argparse\n\n    parser = argparse.ArgumentParser(description=\"TradeTracer Executor Web UI\")\n    parser.add_argument(\"--host\", default=\"0.0.0.0\", help=\"Host to bind to\")\n    parser.add_argument(\"--port\", type=int, default=5000, help=\"Port to bind to\")\n    parser.add_argument(\"--config\", default=\"/data/config.json\", help=\"Config path\")\n    args = parser.parse_args()\n\n    app = create_app(args.config)\n    app.run(host=args.host, port=args.port)\n</code></pre>"}]}